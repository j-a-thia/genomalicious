% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/vcf2DT.R
\name{vcf2DT}
\alias{vcf2DT}
\title{VCF file to data table}
\usage{
vcf2DT(vcfFile, dropCols = NULL, keepComments = FALSE, keepInfo = FALSE)
}
\arguments{
\item{vcfFile}{Character: The path to the input VCF file.}

\item{dropCols}{Character: Vector of column names from the VCF that you
want to drop from the data table. Default = \code{NULL}.
Only relevant when argument \code{flip==FALSE}.}

\item{keepComments}{Logical: Should the VCF comments be kept?
Default = \code{FALSE}. See Details for parameterisation.}

\item{keepInfo}{Logical: Should the VCF info for each locus be kept?
Default = \code{FALSE}.}
}
\value{
A \code{data.table} object is returned with all the columns contained in
the original VCF file with some additions:
\itemize{
    \item A column called \code{LOUCS} is generated. This is the concatenation of the
             \code{CHROM} and \code{POS} column to form a locus ID.
    \item A column called \code{SAMPLE} is generated. This contains the sample IDs that
             are the columns that follow the \code{FORMAT} column in the original VCF.
    \item The items in the original \code{FORMAT} column of the VCF are given their own columns.
} \cr
Note, for VCF files produced by Stacks, the $CHROM is given the same value
as the $ID column. \cr\cr
When \code{keepInfo==TRUE} and/or \code{keepComments==TRUE}, these are returned
as attributes. E.g., if the returned object is \code{vcfDT}, then you can
access Info and Comments (respectively) with: \code{attr(vcfDT, 'vcf_info')}
and \code{attr(vcfDT, 'vcf_comments')}.
}
\description{
Reads a VCF file and converts to a long format data table. Note, that whilst
the \code{data.table} object class is very memory efficient, very large genomic
datasets will take a long time to read in, and/or be difficult to hold in
memory. Take your operating system and the size of your input dataset into
consideration when using this function.
}
\details{
Firstly, it should be noted that while data tables are a really
excellent way of handling genotype and sequence read information in R,
they are not necessarily the most efficient way to do so. Importing VCFs
as data table (or the reverse, exporting data tables as VCFs), can take
a considerable amount of time if the number of loci and samples are large.
However, a bit of patience is worth it! \cr
}
\examples{
# Create a link to raw external datasets in genomalicious
genomaliciousExtData <- paste0(find.package('genomalicious'), '/extdata')

# This command here shows you the VCF file that comes with genomalicious
list.files(path=genomaliciousExtData, pattern='indseq.vcf')

# Use this to create a path to that file
vcfPath <- paste0(genomaliciousExtData, '/data_indseq.vcf')

# You can read the file in as lines to see what it
# looks like:
readLines(vcfPath) \%>\%  head
readLines(vcfPath) \%>\%  tail

# Now read it in as a data table
readVcf1 <- vcf2DT(vcfFile=vcfPath)
readVcf1 \%>\% print()

# Read in VCF, but drop some columns,
# and keep comments and info.
readVcf2 <- vcf2DT(vcfPath
   , dropCols=c('QUAL')
   , keepComments=TRUE
   , keepInfo=TRUE)

readVcf2 \%>\% print

attr(readVcf2, 'vcf_comments')
attr(readVcf2, 'vcf_info')

}
\references{
This & Riginos (2019) genomalicious: serving up a smorgasbord of
R functions for population genomic analyses. BioRxiv.
}
