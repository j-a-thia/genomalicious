CODON=i,
NUC.GENE=c(n-2, n-1, n),
NUC.CODON=1:3,
DNA=strsplit(cod, '')[[1]],
AMINO=amino
)
}
}) %>%
do.call('rbind',.)
# Output
codonTab %>% return()
}
?dna2codonDT
?dna2codonDT
library(genomalicious)
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyverse')
for(L in libs){require(L, character.only=TRUE)}
# Make just those documents that have changed
roxygenise()
library(genomalicious)
library(genomalicious)
data(data_Genos)
# Calculate pairwise FST
pairFst <- fst_calc(data_Genos, type='genos', global=FALSE, pairwise=TRUE)
library(genomalicious)
data(data_Genos)
pairFst <- fst_calc(data_Genos, type='genos', global=FALSE, pairwise=TRUE)
pairFst <- fstat_calc(data_Genos, type='genos', global=FALSE, pairwise=TRUE)
?fstat_calc
pairFst <- fstat_calc(data_Genos, type='genos', fstat='FST', global=FALSE, pairwise=TRUE)
pairFst
pairFst[, paste(Pop1, Pop2)]
pairFst[, paste(POP1, POP2)] -> z
pairFst$locus[, paste(POP1, POP2)] -> z
z
z %>% table
pairFst ->dat
samp.uniq <- rownames(dat)
samp.uniq
rownames(dat)
require(data.table); require(tidyverse)
if(flip==FALSE){
if(!'matrix' %in% class(dat)){
stop('Argument `dat` is not a matrix, but `type` is "FALSE", i.e.,
turn a pairwise matrix into a pairwise data table. See ?pairwiseMat2DT.')
}
}
if(flip==TRUE){
dat <- as.data.table(dat)
if(sum(c(X1, X2, Y) %in% colnames(dat))!=3){
stop('Argument `flip` is "TRUE", i.e., turn a pairwise data table into a
matrix, but not all the the required columns appear to be in `dat`.
Check parameterisation of `X1`, `X2`, and `Y`. See ?pairwiseMat2DT.')
}
}
flip=FALSE
if(flip==FALSE){
if(!'matrix' %in% class(dat)){
stop('Argument `dat` is not a matrix, but `type` is "FALSE", i.e.,
turn a pairwise matrix into a pairwise data table. See ?pairwiseMat2DT.')
}
}
if(flip==TRUE){
dat <- as.data.table(dat)
if(sum(c(X1, X2, Y) %in% colnames(dat))!=3){
stop('Argument `flip` is "TRUE", i.e., turn a pairwise data table into a
matrix, but not all the the required columns appear to be in `dat`.
Check parameterisation of `X1`, `X2`, and `Y`. See ?pairwiseMat2DT.')
}
}
require(data.table); require(tidyverse)
if(flip==FALSE){
if(!'matrix' %in% class(dat)){
stop('Argument `dat` is not a matrix, but `type` is "FALSE", i.e.,
turn a pairwise matrix into a pairwise data table. See ?pairwiseMat2DT.')
}
}
if(flip==TRUE){
dat <- as.data.table(dat)
if(sum(c(X1, X2, Y) %in% colnames(dat))!=3){
stop('Argument `flip` is "TRUE", i.e., turn a pairwise data table into a
matrix, but not all the the required columns appear to be in `dat`.
Check parameterisation of `X1`, `X2`, and `Y`. See ?pairwiseMat2DT.')
}
}
pairFst$locus
pairFst$genome
pairFst$genome -> dat
X1='POP1'
X2='POP2'
Y='FST'
require(data.table); require(tidyverse)
if(flip==FALSE){
if(!'matrix' %in% class(dat)){
stop('Argument `dat` is not a matrix, but `type` is "FALSE", i.e.,
turn a pairwise matrix into a pairwise data table. See ?pairwiseMat2DT.')
}
}
if(flip==TRUE){
dat <- as.data.table(dat)
if(sum(c(X1, X2, Y) %in% colnames(dat))!=3){
stop('Argument `flip` is "TRUE", i.e., turn a pairwise data table into a
matrix, but not all the the required columns appear to be in `dat`.
Check parameterisation of `X1`, `X2`, and `Y`. See ?pairwiseMat2DT.')
}
}
)
pairMat <- pairwiseMat2DT(
dat=pairFst$genome, flip=TRUE, X1='POP1', X2='POP2', Y='FST'
)
pairMat
pairMat -> dat
dat
dat <- pairFst$genome
require(data.table); require(tidyverse)
if(flip==FALSE){
if(!'matrix' %in% class(dat)){
stop('Argument `dat` is not a matrix, but `type` is "FALSE", i.e.,
turn a pairwise matrix into a pairwise data table. See ?pairwiseMat2DT.')
}
}
flip=TRUE
if(flip==FALSE){
if(!'matrix' %in% class(dat)){
stop('Argument `dat` is not a matrix, but `type` is "FALSE", i.e.,
turn a pairwise matrix into a pairwise data table. See ?pairwiseMat2DT.')
}
}
if(flip==TRUE){
dat <- as.data.table(dat)
if(sum(c(X1, X2, Y) %in% colnames(dat))!=3){
stop('Argument `flip` is "TRUE", i.e., turn a pairwise data table into a
matrix, but not all the the required columns appear to be in `dat`.
Check parameterisation of `X1`, `X2`, and `Y`. See ?pairwiseMat2DT.')
}
}
samp.uniq <- rownames(dat)
samp.uniq
dat
dat
pairMat -> dat
samp.uniq <- rownames(dat)
output <- combn(samp.uniq, 2) %>%
t() %>%
as.data.table %>%
setnames(., new=c('X1','X2'))
output
for(i in 1:nrow(output)){
x1 <- output$X1[i]
x2 <- output$X2[i]
output$Y[i] <- dat[x1, x2]
}
output
setnames(output, old=c('X1','X2','Y'), new=c(X1,X2,Y))
output
flip=TRUE
dat <- pairFst$genome
dat
# Flipped: convert a pairiwse data table into matrix.
if(flip==TRUE){
samp.uniq <- c(dat[[X1]], dat[[X2]]) %>%  unique() %>%  sort()
n <- length(samp.uniq)
output <- matrix(0, ncol=n, nrow=n, dimnames=list(samp.uniq, samp.uniq))
for(i in 1:nrow(dat)){
x1.i <- dat[[X1]][i]
x2.i <- dat[[X2]][i]
measure.i <- dat[[Y]][[i]]
output[x1.i, x2.i] <- measure.i
output[x2.i, x1.i] <- measure.i
}
}
output
samp.uniq <- c(dat[[X1]], dat[[X2]]) %>%  unique() %>%  sort()
samp.uniq
dat
dat
dat %>%
dcast(., POP1 ~ POP2, value.var='FST')
dat <- pairFst$genome
dat
pairMat
pairMat -> dat
dat %>%
as.data.frame()
dat %>%
as.data.frame() %>%
rownames_to_column(., 'X1')
dat %>%
as.data.frame() %>%
rownames_to_column(., 'X1') %>%
melt(., id.vars='X1', variable.name='X2', value.var='Y')
dat %>%
as.data.frame() %>%
rownames_to_column(., 'X1') %>%
as.data.table %>%
melt(., id.vars='X1', variable.name='X2', value.var='Y')
dat %>%
as.data.frame() %>%
rownames_to_column(., 'X1') %>%
as.data.table %>%
melt(., id.vars='X1', variable.name='X2', value.name='Y')
dat %>%
as.data.frame() %>%
rownames_to_column(., 'X1') %>%
as.data.table %>%
melt(., id.vars='X1', variable.name='X2', value.name='Y') %>%
setnames(., old=c('X1','X2','Y'), new=c(X1,X2,Y))
output <- dat %>%
as.data.frame() %>%
rownames_to_column(., 'X1') %>%
as.data.table %>%
melt(., id.vars='X1', variable.name='X2', value.name='Y') %>%
setnames(., old=c('X1','X2','Y'), new=c(X1,X2,Y))
output
dat <- pairFst$genome
dat
dat
dat %>%
copy %>%
setnames(., old=c(X1,X2,Y), new=c('X1','X2','Y'))
dat <- dat %>%
copy %>%
setnames(., old=c(X1,X2,Y), new=c('X1','X2','Y'))
dat
samp.uniq <- dat[,c('X1','X2')] %>%
as.vector %>%
unique %>%
sort
dat[,c('X1','X2')] %>%
as.vector
dat[,c('X1','X2')]
samp.uniq <- dat[,c('X1','X2')] %>%
unlist %>%
unique %>%
sort
samp.uniq
rbind(
dat,
data.table(X1=dat$X2, X2=dat$X1, Y=dat$Y)
)
rbind(
dat,
data.table(X1=dat$X2, X2=dat$X1, Y=dat$Y),
data.table(X1=samp.uniq, X2=samp.uniq, Y=0)
)
rbind(
dat,
data.table(X1=dat$X2, X2=dat$X1, Y=dat$Y),
data.table(X1=samp.uniq, X2=samp.uniq, Y=0)
) %>%
dcast(., X1 ~ X2, value.var='Y')
rbind(
dat,
data.table(X1=dat$X2, X2=dat$X1, Y=dat$Y),
data.table(X1=samp.uniq, X2=samp.uniq, Y=0)
) %>%
dcast(., X1 ~ X2, value.var='Y') %>%
as.data.frame %>%
column_to_rownames(., 'X1')
rbind(
dat,
data.table(X1=dat$X2, X2=dat$X1, Y=dat$Y),
data.table(X1=samp.uniq, X2=samp.uniq, Y=0)
) %>%
dcast(., X1 ~ X2, value.var='Y') %>%
as.data.frame %>%
column_to_rownames(., 'X1') %>%
as.matrix()
#' Convert a pairwise matrix into a pairwise data table
#'
#' This function takes pairwise matrix (all possible combinations in rows and
#' columns) and converts it into a long-format data table. This function can
#' also be flipped, i.e., going from a pairwise data table to a pairwise matrix.
#'
#' @param dat Matrix or Data table: The default parameterisation (\code{flip==FALSE})
#' is expecting a pairwise matrix. This matrix needs to be symmetrical, with a
#' zero on the diagonal and the off-diagonal containing the measured variable
#' values between pairs. There should be row and column names. If instead you
#' want to go in the flipped parameterisation (\code{flip==TRUE}), then a
#' data table is expected, where pair combinations are represented into two
#' columns and the measured variable is in a third column.
#'
#' @param flip Logical: Should the function be flipped? Default is \code{FALSE},
#' a pairwise matrix should be converted into a pairwise data table. If set to
#' \code{TRUE}, then a pairwise data table is converted into a matrix.
#'
#' @param X1 Character: The column name for the first member of the pair.
#' If \code{flip==FALSE}, then \code{X1} will take the row names from the matrix
#' and put them into the first column of the output data table.
#' If \code{flip==TRUE}, then \code{X1} will be take the column in the data table and
#' put it as row names in the output matrix.
#'
#' @param X2 Character: The column name for the first member of the pair.
#' If \code{flip==FALSE}, then \code{X2} will take the column names from the matrix
#' and put them into the second column of the output data table.
#' If \code{flip==TRUE}, then \code{X2} will be take the column in the data table and
#' put it as column names in the output matrix.
#'
#' @param Y Character: The column name or the measured variable between pairs.
#' If \code{flip==FALSE}, then \code{Y} will take the values in the off-diagonal
#' in the matrix and put them into the third column of the output data table.
#' If \code{flip==TRUE}, then \code{Y} will be take the column in the data table and
#' put it as values in the off-diagonal in the output matrix.
#'
#' @examples
#' library(genomalicious)
#' data(data_Genos)
#'
#' # Calculate pairwise FST
#' pairFst <- fstat_calc(data_Genos, type='genos', fstat='FST', global=FALSE, pairwise=TRUE)
#'
#' # Convert into a pairwise matrix
#' pairMat <- pairwiseMat2DT(
#'    dat=pairFst$genome, flip=TRUE, X1='POP1', X2='POP2', Y='FST'
#' )
#' pairMat
#'
#' # Convert the pairwise matrix into a data table
#' pairDT <- pairwiseMat2DT(
#'    dat=pairMat, flip=FALSE, X1='POP1', X2='POP2', Y='FST'
#' )
#' pairDT
#'
#' @export
pairwiseMat2DT <- function(dat, flip=FALSE, X1, X2, Y){
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
require(data.table); require(tidyverse)
if(flip==FALSE){
if(!'matrix' %in% class(dat)){
stop('Argument `dat` is not a matrix, but `type` is "FALSE", i.e.,
turn a pairwise matrix into a pairwise data table. See ?pairwiseMat2DT.')
}
}
if(flip==TRUE){
dat <- as.data.table(dat)
if(sum(c(X1, X2, Y) %in% colnames(dat))!=3){
stop('Argument `flip` is "TRUE", i.e., turn a pairwise data table into a
matrix, but not all the the required columns appear to be in `dat`.
Check parameterisation of `X1`, `X2`, and `Y`. See ?pairwiseMat2DT.')
}
}
# --------------------------------------------+
# Code
# --------------------------------------------+
# Convert a pairwise matrix into a data table
if(flip==FALSE){
output <- dat %>%
as.data.frame() %>%
rownames_to_column(., 'X1') %>%
as.data.table %>%
melt(., id.vars='X1', variable.name='X2', value.name='Y') %>%
setnames(., old=c('X1','X2','Y'), new=c(X1,X2,Y))
}
# Flipped: convert a pairiwse data table into matrix.
if(flip==TRUE){
dat <- dat %>%
copy %>%
setnames(., old=c(X1,X2,Y), new=c('X1','X2','Y'))
samp.uniq <- dat[,c('X1','X2')] %>%
unlist %>%
unique %>%
sort
output <- rbind(
dat,
data.table(X1=dat$X2, X2=dat$X1, Y=dat$Y),
data.table(X1=samp.uniq, X2=samp.uniq, Y=0)
) %>%
dcast(., X1 ~ X2, value.var='Y') %>%
as.data.frame %>%
column_to_rownames(., 'X1')
}
# Output
return(output)
}
pairFst <- fstat_calc(data_Genos, type='genos', fstat='FST', global=FALSE, pairwise=TRUE)
pairMat <- pairwiseMat2DT(
dat=pairFst$genome, flip=TRUE, X1='POP1', X2='POP2', Y='FST'
)
pairMat
pairDT <- pairwiseMat2DT(
dat=pairMat, flip=FALSE, X1='POP1', X2='POP2', Y='FST'
)
pairDT
#' Convert a pairwise matrix into a pairwise data table
#'
#' This function takes pairwise matrix (all possible combinations in rows and
#' columns) and converts it into a long-format data table. This function can
#' also be flipped, i.e., going from a pairwise data table to a pairwise matrix.
#'
#' @param dat Matrix or Data table: The default parameterisation (\code{flip==FALSE})
#' is expecting a pairwise matrix. This matrix needs to be symmetrical, with a
#' zero on the diagonal and the off-diagonal containing the measured variable
#' values between pairs. There should be row and column names. If instead you
#' want to go in the flipped parameterisation (\code{flip==TRUE}), then a
#' data table is expected, where pair combinations are represented into two
#' columns and the measured variable is in a third column.
#'
#' @param flip Logical: Should the function be flipped? Default is \code{FALSE},
#' a pairwise matrix should be converted into a pairwise data table. If set to
#' \code{TRUE}, then a pairwise data table is converted into a matrix.
#'
#' @param X1 Character: The column name for the first member of the pair.
#' If \code{flip==FALSE}, then \code{X1} will take the row names from the matrix
#' and put them into the first column of the output data table.
#' If \code{flip==TRUE}, then \code{X1} will be take the column in the data table and
#' put it as row names in the output matrix.
#'
#' @param X2 Character: The column name for the first member of the pair.
#' If \code{flip==FALSE}, then \code{X2} will take the column names from the matrix
#' and put them into the second column of the output data table.
#' If \code{flip==TRUE}, then \code{X2} will be take the column in the data table and
#' put it as column names in the output matrix.
#'
#' @param Y Character: The column name or the measured variable between pairs.
#' If \code{flip==FALSE}, then \code{Y} will take the values in the off-diagonal
#' in the matrix and put them into the third column of the output data table.
#' If \code{flip==TRUE}, then \code{Y} will be take the column in the data table and
#' put it as values in the off-diagonal in the output matrix.
#'
#' @examples
#' library(genomalicious)
#' data(data_Genos)
#'
#' # Calculate pairwise FST
#' pairFst <- fstat_calc(data_Genos, type='genos', fstat='FST', global=FALSE, pairwise=TRUE)
#'
#' # Convert into a pairwise matrix
#' pairMat <- pairwiseMat2DT(
#'    dat=pairFst$genome, flip=TRUE, X1='POP1', X2='POP2', Y='FST'
#' )
#' pairMat
#'
#' # Convert the pairwise matrix into a data table
#' pairDT <- pairwiseMat2DT(
#'    dat=pairMat, flip=FALSE, X1='POP1', X2='POP2', Y='FST'
#' )
#' pairDT
#'
#' @export
pairwiseMat2DT <- function(dat, flip=FALSE, X1, X2, Y){
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
require(data.table); require(tidyverse)
if(flip==FALSE){
if(!'matrix' %in% class(dat)){
stop('Argument `dat` is not a matrix, but `type` is "FALSE", i.e.,
turn a pairwise matrix into a pairwise data table. See ?pairwiseMat2DT.')
}
}
if(flip==TRUE){
dat <- as.data.table(dat)
if(sum(c(X1, X2, Y) %in% colnames(dat))!=3){
stop('Argument `flip` is "TRUE", i.e., turn a pairwise data table into a
matrix, but not all the the required columns appear to be in `dat`.
Check parameterisation of `X1`, `X2`, and `Y`. See ?pairwiseMat2DT.')
}
}
# --------------------------------------------+
# Code
# --------------------------------------------+
# Convert a pairwise matrix into a data table
if(flip==FALSE){
output <- dat %>%
as.data.frame() %>%
rownames_to_column(., 'X1') %>%
as.data.table %>%
melt(., id.vars='X1', variable.name='X2', value.name='Y') %>%
setnames(., old=c('X1','X2','Y'), new=c(X1,X2,Y))
}
# Flipped: convert a pairiwse data table into matrix.
if(flip==TRUE){
dat <- dat %>%
copy %>%
setnames(., old=c(X1,X2,Y), new=c('X1','X2','Y'))
samp.uniq <- dat[,c('X1','X2')] %>%
unlist %>%
unique %>%
sort
output <- rbind(
dat,
data.table(X1=dat$X2, X2=dat$X1, Y=dat$Y),
data.table(X1=samp.uniq, X2=samp.uniq, Y=0)
) %>%
dcast(., X1 ~ X2, value.var='Y') %>%
as.data.frame %>%
column_to_rownames(., 'X1') %>%
as.matrix()
}
# Output
return(output)
}
# Calculate pairwise FST
pairFst <- fstat_calc(data_Genos, type='genos', fstat='FST', global=FALSE, pairwise=TRUE)
# Convert into a pairwise matrix
pairMat <- pairwiseMat2DT(
dat=pairFst$genome, flip=TRUE, X1='POP1', X2='POP2', Y='FST'
)
pairMat
pairDT <- pairwiseMat2DT(
dat=pairMat, flip=FALSE, X1='POP1', X2='POP2', Y='FST'
)
pairDT
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyverse')
for(L in libs){require(L, character.only=TRUE)}
# Make all documents
roxygenise(clean=TRUE)
library(genomalicious)
