#' ### COMPARE THE OBSERVED AND SIMULATED
#' relComp <- family_sim_compare(
#'    simFamily=simFamily,
#'    simGRM=simGRM,
#'    obsGRM=obsGRM,
#'    look='classic'
#' )
#'
#' # The data
#' relComp$data
#'
#' # Plot of relatedness values. Dashed lines denote relatedness
#' # values of 0, 0.125, 0.25, and 0.5, which are the theoretical
#' # expectations for unrelated individuals, cousins, half-siblings,
#' # and siblings, respectively.
#' # You will note a large variance are the expected values, which
#' # is not surprising for this very small SNP dataset (200 loci).
#' relComp$plot
#'
#' # Take a look at the "known" relationships in the observed dataset
#' # Note, siblings and parent-offspring pairs have a theoretical
#' # relatedness of 0.5. But you will probably find the "observed"
#' # relatedness values are much lower.
#' relComp$data[SAMPLE1=='Child_1.2_1' & SAMPLE2%in%c('Child_1.2_2','Ind1_1','Ind1_2')]
#' relComp$data[SAMPLE1=='Child_29.30_1' & SAMPLE2%in%c('Child_29.30_2','Ind1_29','Ind1_30')]
#'
#' # Now take a look at the simulated distribution.
#' relComp$data[FAMILY=='Half-siblings']$RELATE %>% summary()
#' relComp$data[FAMILY=='Siblings']$RELATE %>% summary()
#'
#' @export
family_sim_compare <- function(
simFamily, simGRM, obsGRM, plotColous=NULL, look='ggplot', legendPos='right',
curveAlpha=0.7, curveFill=NULL, curveOutline=NULL
){
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
require(data.table); require(ggplot2); require(tidyverse)
# Adjust values for curveOutline if NULL or if length != 6
if(is.null(curveOutline)){
curveOutline <- rep('grey20', 6)
}
if(length(curveOutline)<6){
curveOutline <- rep(curveOutline[1], 6)
}
# Check that fill colours are specified correctly if NULL, and
# if not NULL, make sure there are only 5 colours
if(!is.null(curveFill)){
if(length(curveFill)!=6){
stop('Argument `curveFill` must be a character vector of 5 colours. See ?family_sim_plot.')
}
}
if(is.null(curveFill)){
curveFill <- c("#F05F5F", "#E8CE00", "#54C567", "#02CEF2", "#4F74E6", "#DA5EE4")
}
# Legend position
if(!legendPos %in% c('top','right','left','bottom')){
stop('Argument `legendPos` must be on of "top", "right", "left", and "bottom". See ?family_sim_plot.')
}
# Set the plot theme by look
if(!look %in% c('ggplot','classic')){
stop('Argument `look` must be one of "ggplot" or "classic". See ?family_sim_plot.')
}
if(look=='ggplot'){
plotTheme <- theme_gray() + theme(legend.position=legendPos, axis.ticks.length = unit(0.2, 'cm'))
} else if(look=='classic'){
plotTheme <- theme_bw() + theme(
panel.grid.major=element_blank()
, panel.grid.minor=element_blank()
, text=element_text(colour='black')
, legend.position=legendPos
, axis.ticks.length=unit(0.2, 'cm'))
}
# --------------------------------------------+
# Code
# --------------------------------------------+
# Number of sims
numSims <- simFamily$SIM %>% max
# Compile the relatedness data table from simulated and observed GRMs.
simRel <- lapply(1:numSims, function(sim){
# Line up the known pairs. Note, that samples with "G3.2" are half-siblings
# with "G3.3" and cousins with "G3.4". But these relationships are not
# included to keep things balanced.
unrel <- c(paste0('S',sim,c('_unrel_1','_unrel_2')))
sibs <- c(paste0('S',sim,c('_sib_1','_sib_2')))
halfsibs <- c(paste0('S',sim,c('_halfsib_1','_halfsib_2')))
cousins <- c(paste0('S',sim,c('_cous_1','_cous_2')))
halfcousins <- c(paste0('S',sim,c('_halfcous_1','_halfcous_2')))
data.table(
SIM=sim,
SAMPLE1=c(unrel[1],sibs[1],halfsibs[1],cousins[1],halfcousins[1]),
SAMPLE2=c(unrel[2],sibs[2],halfsibs[2],cousins[2],halfcousins[2]),
FAMILY=c('Unrelated','Siblings','Half-siblings','Cousins','Half-cousins'),
RELATE=c(
simGRM[unrel[1],unrel[2]],
simGRM[sibs[1],sibs[2]],
simGRM[halfsibs[1],halfsibs[2]],
simGRM[cousins[1],cousins[2]],
simGRM[halfcousins[1],halfcousins[2]]
)
)
}) %>%
do.call('rbind', .)
obsRel <- combn(colnames(obsGRM),2) %>%
apply(., 2, function(x){
data.table(SIM=NA, SAMPLE1=x[1], SAMPLE2=x[2], FAMILY='Observed', RELATE=obsGRM[x[1],x[2]])
}) %>%
do.call('rbind', .)
# Make the data
rel_data <- rbind(obsRel, simRel) %>%
as.data.table %>%
.[, FAMILY:=factor(FAMILY, levels=c('Unrelated','Half-cousins','Cousins','Half-siblings','Siblings','Observed'))]
# Make the plot
rel_gg <- ggplot(rel_data, aes(x=RELATE, fill=FAMILY, colour=FAMILY)) +
plotTheme +
geom_density(alpha=curveAlpha,position="identity") +
geom_vline(xintercept=c(0,0.0625,0.125,0.25,0.5), linetype='longdash') +
scale_colour_manual(values=curveOutline) +
scale_fill_manual(values=curveFill) +
scale_x_continuous(breaks=seq(-0.1, 1, 0.1)) +
labs(x='Relatedness', y='Density', fill='', colour='')
# Return a list
list(data=rel_data, plot=rel_gg) %>% return()
}
library(genomalicious)
data(data_Genos)
# Subset Pop1 genotypes
genosPop1 <- data_Genos[POP=='Pop1', c('SAMPLE', 'LOCUS', 'GT')]
# Get the allele frequencies for Pop1
freqsPop1 <- genosPop1[, .(FREQ=sum(GT)/(length(GT)*2)), by=LOCUS]
# Simulate 100 families
simFamily <- family_sim_data(
freqData=freqsPop1,
locusCol='LOCUS',
freqCol='FREQ',
numSims=100
)
# Create some siblings in Pop1 from two sets of parents
parentList <- list(c('Ind1_1','Ind1_2'), c('Ind1_3','Ind1_4'))
genosSibs <- lapply(1:2, function(i){
parents <- parentList[[i]]
child <- paste(sub('Ind1_', '', parents), collapse='.')
gamete1 <- genosPop1[SAMPLE == parents[1]] %>%
.[, .(GAMETE=rbinom(n=2,size=1,prob=GT/2)), by=c('SAMPLE','LOCUS')] %>%
.[, SIB:=1:2, by=LOCUS]
gamete2 <- genosPop1[SAMPLE == parents[2]] %>%
.[, .(GAMETE=rbinom(n=2,size=1,prob=GT/2)), by=c('SAMPLE','LOCUS')] %>%
.[, SIB:=1:2, by=LOCUS]
rbind(gamete1, gamete2) %>%
.[, .(GT=sum(GAMETE)), by=c('LOCUS','SIB')] %>%
.[, SAMPLE:=paste0('Child_',child,'_',SIB)]
}) %>%
do.call('rbind', .)
### THE OBSERVED GENETIC RELATIONSHIPS MATRIX
library(AGHmatrix)
# Combine the population samples and the created siblings
# into a single genotype matrix
obsGenosMat <- rbind(genosPop1, genosSibs[, c('SAMPLE','LOCUS','GT')]) %>%
DT2Mat_genos()
# Calculate the GRM
obsGRM <- Gmatrix(obsGenosMat, method='Yang', ploidy=2)
### THE SIMULATED GENETIC RELATIONSHIPS MATRIX
# Convert simulated families into a genotype matrix
simGenosMat <- DT2Mat_genos(simFamily)
# Calculate the GRM
simGRM <- Gmatrix(simGenosMat, method='Yang', ploidy=2)
### COMPARE THE OBSERVED AND SIMULATED
relComp <- family_sim_compare(
simFamily=simFamily,
simGRM=simGRM,
obsGRM=obsGRM,
look='classic'
)
relComp$data
relComp$data
relComp$data[is.na(SIM)]
relComp$data[!is.na(SIM)]
relComp$plot
relComp$data[SAMPLE1=='Child_1.2_1' & SAMPLE2%in%c('Child_1.2_2','Ind1_1','Ind1_2')]
relComp$data[SAMPLE1=='Child_3.4_1' & SAMPLE2%in%c('Child_3.4_2','Ind1_3','Ind1_4')]
# Now take a look at the simulated distribution.
relComp$data[FAMILY=='Half-siblings']$RELATE %>% summary()
relComp$data[FAMILY=='Siblings']$RELATE %>% summary()
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyverse')
for(L in libs){require(L, character.only=TRUE)}
# Make just those documents that have changed
roxygenise()
library(genomalicious)
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyverse')
for(L in libs){require(L, character.only=TRUE)}
library(genomalicious)
data(data_Genos)
pairFst <- fstat_calc(data_Genos, type='genos', fstat='FST', global=FALSE, pairwise=TRUE)
pairFst
pairMat <- pairwiseMat2DT(
dat=pairFst$genome, flip=TRUE, X1='POP1', X2='POP2', Y='FST',
diagAdd=TRUE, diagVal=0
)
pairMat
pairDT <- pairwiseMat2DT(
dat=pairMat, flip=FALSE, X1='POP1', X2='POP2', Y='FST'
)
pairDT
dat=pairMat
flip=FALSE
X1='POP1'
X2='POP2'
Y='FST'
diagAdd=TRUE
diagVal=0
require(data.table); require(tidyverse)
if(flip==FALSE){
if(!'matrix' %in% class(dat)){
stop('Argument `dat` is not a matrix, but `type` is "FALSE", i.e.,
turn a pairwise matrix into a pairwise data table. See ?pairwiseMat2DT.')
}
}
if(flip==TRUE){
dat <- as.data.table(dat)
# Check for appropriate columns
if(sum(c(X1, X2, Y) %in% colnames(dat))!=3){
stop('Argument `flip` is "TRUE", i.e., turn a pairwise data table into a
matrix, but not all the the required columns appear to be in `dat`.
Check parameterisation of `X1`, `X2`, and `Y`. See ?pairwiseMat2DT.')
}
# Check to make sure diagonal parameterisation is correct. If the data.table
# already contains information for the diagonal, then choosing `diagAdd==TRUE`
# will cause an error.
within <- sum(dat[[X1]]==dat[[X2]])
if(within>0 & diagAdd==TRUE){
stop_msg <- paste0(
'Argument `diagAdd` is "TRUE", but there are ', within,
' within-subject comparisons: ' ,
'`diagAdd` should only be "TRUE" if there are no within-subject ',
'measurements. See ?pairwiseMat2DT'
)
stop(stop_msg)
}
}
diagAdd=FALSE
require(data.table); require(tidyverse)
if(flip==FALSE){
if(!'matrix' %in% class(dat)){
stop('Argument `dat` is not a matrix, but `type` is "FALSE", i.e.,
turn a pairwise matrix into a pairwise data table. See ?pairwiseMat2DT.')
}
}
if(flip==TRUE){
dat <- as.data.table(dat)
# Check for appropriate columns
if(sum(c(X1, X2, Y) %in% colnames(dat))!=3){
stop('Argument `flip` is "TRUE", i.e., turn a pairwise data table into a
matrix, but not all the the required columns appear to be in `dat`.
Check parameterisation of `X1`, `X2`, and `Y`. See ?pairwiseMat2DT.')
}
# Check to make sure diagonal parameterisation is correct. If the data.table
# already contains information for the diagonal, then choosing `diagAdd==TRUE`
# will cause an error.
within <- sum(dat[[X1]]==dat[[X2]])
if(within>0 & diagAdd==TRUE){
stop_msg <- paste0(
'Argument `diagAdd` is "TRUE", but there are ', within,
' within-subject comparisons: ' ,
'`diagAdd` should only be "TRUE" if there are no within-subject ',
'measurements. See ?pairwiseMat2DT'
)
stop(stop_msg)
}
}
# Convert a pairwise matrix into a data table
if(flip==FALSE){
output <- dat %>%
as.data.frame() %>%
rownames_to_column(., 'X1') %>%
as.data.table %>%
melt(., id.vars='X1', variable.name='X2', value.name='Y') %>%
setnames(., old=c('X1','X2','Y'), new=c(X1,X2,Y))
}
dat
dat <- dat %>%
copy %>%
setnames(., old=c(X1,X2,Y), new=c('X1','X2','Y'))
output <- dat %>%
as.data.frame() %>%
rownames_to_column(., 'X1') %>%
as.data.table %>%
melt(., id.vars='X1', variable.name='X2', value.name='Y') %>%
setnames(., old=c('X1','X2','Y'), new=c(X1,X2,Y))
output
dat
is.na(dat)
sum(is.na(dat))
stop('Argument `dat` has NAs. If there is missing data, please encode it
in a different way.')
stop('Argument `dat` has NAs. If there is missing data, please encode it in a different way.')
dat[upper.tri(dat, diag=FALSE)] <- NA
dat
sum(is.na(dat))
output <- dat %>%
as.data.frame() %>%
rownames_to_column(., 'X1') %>%
as.data.table %>%
melt(., id.vars='X1', variable.name='X2', value.name='Y') %>%
setnames(., old=c('X1','X2','Y'), new=c(X1,X2,Y))
output
output <- dat %>%
as.data.frame() %>%
rownames_to_column(., 'X1') %>%
as.data.table %>%
.[!is.na(Y)] %>%
melt(., id.vars='X1', variable.name='X2', value.name='Y') %>%
setnames(., old=c('X1','X2','Y'), new=c(X1,X2,Y))
output
dat %>%
as.data.frame() %>%
rownames_to_column(., 'X1') %>%
as.data.table
dat %>%
as.data.frame() %>%
rownames_to_column(., 'X1') %>%
as.data.table %>%
melt(., id.vars='X1', variable.name='X2', value.name='Y') %>%
.[!is.na(Y)]
dat[upper.tri(dat, diag=FALSE)] <- NA
output <- dat %>%
as.data.frame() %>%
rownames_to_column(., 'X1') %>%
as.data.table %>%
melt(., id.vars='X1', variable.name='X2', value.name='Y') %>%
.[!is.na(Y)] %>%
setnames(., old=c('X1','X2','Y'), new=c(X1,X2,Y))
output
dat <- output
dat
dat <- dat %>%
copy %>%
setnames(., old=c(X1,X2,Y), new=c('X1','X2','Y'))
dat
samp.uniq <- dat[,c('X1','X2')] %>%
unlist %>%
unique %>%
sort
samp.uniq
dat[,c('X1','X2')]
dat[,c('X1','X2')] %>%
unlist
#' Convert a pairwise matrix into a pairwise data table
#'
#' This function takes pairwise matrix (all possible combinations in rows and
#' columns) and converts it into a long-format data table. This function can
#' also be flipped, i.e., going from a pairwise data table to a pairwise matrix.
#'
#' @param dat Matrix or Data table: The default parameterisation (\code{flip==FALSE})
#' is expecting a pairwise matrix. This matrix needs to be symmetrical, with a
#' values on the diagonal representing comparisons within a subject, and values on
#' the off-diagonal containing the measures between subject pairs.
#' There should be row and column names. If instead you want to go in the
#' flipped parameterisation (\code{flip==TRUE}), then a data table is expected,
#' where pair combinations are represented into two columns and the measured
#' variable is in a third column. In this second parameterisation, the data table
#' does not need to have within-subject comparisons (diagonals; you can add these in).
#'
#' @param flip Logical: Should the function be flipped? Default is \code{FALSE},
#' a pairwise matrix should be converted into a pairwise data table. If set to
#' \code{TRUE}, then a pairwise data table is converted into a matrix.
#'
#' @param X1 Character: The column name for the first member of the pair.
#' If \code{flip==FALSE}, then \code{X1} will take the row names from the matrix
#' and put them into the first column of the output data table.
#' If \code{flip==TRUE}, then \code{X1} will be take the column in the data table and
#' put it as row names in the output matrix.
#'
#' @param X2 Character: The column name for the first member of the pair.
#' If \code{flip==FALSE}, then \code{X2} will take the column names from the matrix
#' and put them into the second column of the output data table.
#' If \code{flip==TRUE}, then \code{X2} will be take the column in the data table and
#' put it as column names in the output matrix.
#'
#' @param Y Character: The column name or the measured variable between pairs.
#' If \code{flip==FALSE}, then \code{Y} will take the values in the off-diagonal
#' in the matrix and put them into the third column of the output data table.
#' If \code{flip==TRUE}, then \code{Y} will be take the column in the data table and
#' put it as values in the off-diagonal in the output matrix.
#'
#' @param diagAdd Logical: Should the diagonal be added? Default is
#' \code{TRUE}. Only takes effect if \code{flip==TRUE}.
#'
#' @param diagVal Numeric: The value to add along the diagonal when
#' \code{diagAdd==TRUE}. Default is 0.
#'
#' @examples
#' library(genomalicious)
#' data(data_Genos)
#'
#' # Calculate pairwise FST
#' pairFst <- fstat_calc(data_Genos, type='genos', fstat='FST', global=FALSE, pairwise=TRUE)
#'
#' # Convert into a pairwise matrix
#' pairMat <- pairwiseMat2DT(
#'    dat=pairFst$genome, flip=TRUE, X1='POP1', X2='POP2', Y='FST',
#'    diagAdd=TRUE, diagVal=0
#' )
#' pairMat
#'
#' # Convert the pairwise matrix into a data table
#' pairDT <- pairwiseMat2DT(
#'    dat=pairMat, flip=FALSE, X1='POP1', X2='POP2', Y='FST'
#' )
#' pairDT
#'
#' @export
pairwiseMat2DT <- function(dat, flip=FALSE, X1, X2, Y, diagAdd=TRUE, diagVal=0){
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
require(data.table); require(tidyverse)
if(flip==FALSE){
if(!'matrix' %in% class(dat)){
stop('Argument `dat` is not a matrix, but `type` is "FALSE", i.e.,
turn a pairwise matrix into a pairwise data table. See ?pairwiseMat2DT.')
}
if(sum(is.na(dat))>0){
stop('Argument `dat` has NAs. If there is missing data, please encode it in a different way.')
}
}
if(flip==TRUE){
dat <- as.data.table(dat)
# Check for appropriate columns
if(sum(c(X1, X2, Y) %in% colnames(dat))!=3){
stop('Argument `flip` is "TRUE", i.e., turn a pairwise data table into a
matrix, but not all the the required columns appear to be in `dat`.
Check parameterisation of `X1`, `X2`, and `Y`. See ?pairwiseMat2DT.')
}
# Check to make sure diagonal parameterisation is correct. If the data.table
# already contains information for the diagonal, then choosing `diagAdd==TRUE`
# will cause an error.
within <- sum(dat[[X1]]==dat[[X2]])
if(within>0 & diagAdd==TRUE){
stop_msg <- paste0(
'Argument `diagAdd` is "TRUE", but there are ', within,
' within-subject comparisons: ' ,
'`diagAdd` should only be "TRUE" if there are no within-subject ',
'measurements. See ?pairwiseMat2DT'
)
stop(stop_msg)
}
}
# --------------------------------------------+
# Code
# --------------------------------------------+
# Convert a pairwise matrix into a data table
if(flip==FALSE){
dat[upper.tri(dat, diag=FALSE)] <- NA
output <- dat %>%
as.data.frame() %>%
rownames_to_column(., 'X1') %>%
as.data.table %>%
melt(., id.vars='X1', variable.name='X2', value.name='Y') %>%
.[!is.na(Y)] %>%
setnames(., old=c('X1','X2','Y'), new=c(X1,X2,Y))
}
# Flipped: convert a pairiwse data table into matrix.
if(flip==TRUE){
dat <- dat %>%
copy %>%
setnames(., old=c(X1,X2,Y), new=c('X1','X2','Y'))
samp.uniq <- dat[,c('X1','X2')] %>%
unlist %>%
unique %>%
sort
if(diagAdd==TRUE){
dat2cast <- rbind(
# Data in X1-X2 orientation
dat[, c('X1','X2','Y')],
# Data in X2-X1 orientation
data.table(X1=dat$X2, X2=dat$X1, Y=dat$Y),
# The diagonal
data.table(X1=samp.uniq, X2=samp.uniq, Y=diagVal)
)
} else if(diagAdd==FALSE){
dat2cast <- dat[, c('X1','X2','Y')]
}
output <- dat2cast %>%
data.table::dcast(., X1 ~ X2, value.var = 'Y') %>%
as.data.frame %>%
column_to_rownames(., 'X1') %>%
as.matrix()
}
# Output
return(output)
}
data(data_Genos)
pairFst <- fstat_calc(data_Genos, type='genos', fstat='FST', global=FALSE, pairwise=TRUE)
pairFst
pairMat <- pairwiseMat2DT(
dat=pairFst$genome, flip=TRUE, X1='POP1', X2='POP2', Y='FST',
diagAdd=TRUE, diagVal=0
)
pairMat
pairDT <- pairwiseMat2DT(
dat=pairMat, flip=FALSE, X1='POP1', X2='POP2', Y='FST'
)
pairDT
pairFst
pairFst$genome[POP1=='Pop1' & POP2=='Pop2']
pairFst$genome[POP1=='Pop2' & POP2=='Pop1']
# Make all documents
roxygenise(clean=TRUE)
library(genomalicious)
