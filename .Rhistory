if(!'data.table' %in% class(famGenos)){
stop('Argument `famGenos` must be a data.table class. See ?family_sim_qtl.')
}
if(sum(req.cols %in% colnames(famGenos))!=3){
stop('Not all required columns are in argument `famGenos`. See ?family_sim_qtl.')
}
qtlLoci=NULL
# Checks for famGenos
req.cols <- c('GT','LOCUS','SAMPLE')
if(!'data.table' %in% class(famGenos)){
stop('Argument `famGenos` must be a data.table class. See ?family_sim_qtl.')
}
if(sum(req.cols %in% colnames(famGenos))!=3){
stop('Not all required columns are in argument `famGenos`. See ?family_sim_qtl.')
}
# Make sure only one of numLoci and qtlLoci are specified
if(is.null(numLoci) & is.null(qtlLoci)){
stop('Neither arugment `numLoci` or `qtlLoci` has been specified, but you must specify one of these. See ?family_sim_qtl.')
}
if(!is.null(numLoci) & !is.null(qtlLoci)){
stop('Both arguments `numLoci` and `qtlLoci` have been specified, but you must only specifcy one of these. See ?family_sim_qtl.')
}
# Make sure that numLoci is <= the total number of loci
loc.uniq <- unique(famGenos$LOCUS)
if(!is.null(numLoci)){
if(numLoci>length(loc.uniq) ){
stop('Argument `numLoci` must be <= the total number of unique loci in `famGenos$LOCUS`. See ?family_sim_qtl.')
}
}
# --------------------------------------------+
# Code
# --------------------------------------------+
# Unique loci and their frequencies
uniqLocTab <- unique(famGenos[,.(FREQ=sum(GT)/(length(GT)*2)),LOCUS])
# Reassign values for variance components
Va_t <- additiveVar
Ve_t <- environVar
# Subset a set of loci to underpin the trait
if(is.null(numLoci)==FALSE){
n <- numLoci
traitLocTab <- uniqLocTab[sample(1:nrow(uniqLocTab), size=n, replace=FALSE),]
} else if(is.null(qtlLoci)==FALSE){
traitLocTab <- uniqLocTab[LOCUS %in% qtlLoci]
n <- length(qtlLoci)
}
# Frequency of trait loci
p_vec <- traitLocTab$FREQ
q_vec <- 1 - p_vec
# The effect of the AA genotype (a) and the Aa genotype (d)
a <- 1
d <- 0
# An initial calculation of the variance per locus. This won't sum to the
# desired amount, so have to scale the per locus variance
Va_i_vec <- 2 * p_vec * q_vec * (a + d * (q_vec - p_vec))^2
sum(Va_i_vec)
Va_i_vec <- Va_i_vec * (Va_t / sum(Va_i_vec))
sum(Va_i_vec)
# We also need to scale the AA effect per locus after scaling the variance
# per locus. All loci should have the same effect, unless the locus is
# fixed for one of the two alleles.
a_vec <- lapply(1:n, function(i){
# If: Va_i == 2pq[a + d(q - p)]^2, and if d = 0, then the solution is
# Va_i == 2pq[a]^2, so a == sqrt(Va_i/2pq)
v_i <- Va_i_vec[i]
p_i <- p_vec[i]
q_i <- q_vec[i]
a_i <- sqrt(v_i / (2*p_i*q_i))
if_else(is.na(a_i), 0, a_i)
}) %>% unlist()
# Using the scaled effects
sum(2 * p_vec * q_vec * (a_vec + d * (q_vec - p_vec))^2)
# Add into the table of trait loci
traitLocTab$A.VAL <- a_vec
# Combine the trait loci into the genotype table and calculate the
# additive genotypic effects
simFamTraits <- left_join(famGenos, traitLocTab[, c('LOCUS','A.VAL')]) %>%
# Remove loci with no contributions
.[!is.na(A.VAL)] %>%
# If genotype is 0, breeding value is +a.
.[GT==0, G:=A.VAL] %>%
# If genotype is 1, breeding value is 0.
.[GT==1, G:=0] %>%
# If genotype is 2, breeding value is -a.
.[GT==2, G:=-A.VAL] %>%
# Sum the breeding values
.[, .(G=sum(G)), by=SAMPLE]
simFamTraits$G %>% var
# Add in an environmental deviation per individual.
simFamTraits$E <- rnorm(nrow(simFamTraits), mean=0, sd=sqrt(Ve_t))
simFamTraits$E <- simFamTraits$E * (sqrt(Ve_t) / sd(simFamTraits$E))
simFamTraits$E %>% var
# The phenotype as a combination of genotypic and environmental effects
simFamTraits[, P:=G+E, by=SAMPLE]
# Output
list(trait=simFamTraits, loci=traitLocTab) %>%
return()
library(genomalicious)
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyverse')
for(L in libs){require(L, character.only=TRUE)}
# Make just those documents that have changed
roxygenise()
library(genomalicious)
# Make just those documents that have changed
roxygenise()
library(genomalicious)
?polyrad_DT2RADdata
?adegenet_DT2genX
?poolfstat_DT2pooldata
library(genomalicious)
# Load in the pool metadata and reads
data(data_PoolInfo)
data(data_PoolFreqs)
# Pool info
data_PoolInfo
# Pool reads in $DP, $AO, and $RO
data_PoolFreqs[, c('POOL','DP','AO','RO')]
pooldataObj <-poolfstat_DT2pooldata(
data_PoolFreqs,
flip=FALSE,
poolInfo=data_PoolInfo
)
install.packages("poolfstat")
class(pooldataObj)
pooldataObj <-poolfstat_DT2pooldata(
data_PoolFreqs,
flip=FALSE,
poolInfo=data_PoolInfo
)
class(pooldataObj)
library(genomalicious)
library(genomalicious)
####   MISSING GENOTYPE DATA   ####
data(data_Genos)
datGt <- data_Genos
library(genomalicious)
####   MISSING GENOTYPE DATA   ####
data(data_Genos)
datGt <- data_Genos
# Add missing values
datGt <- do.call(
'rbind',
# Split data table by sample, and iterate through samples, X
split(datGt, by='POP') %>%
lapply(., function(Dpop){
pop <- Dpop$POP[1]
if(pop=='Pop1'){
pr <- 0.1
} else if(pop=='Pop2'){
pr <- 0.2
} else if(pop %in% c('Pop3','Pop4')){
pr <- 0.05
}
# Numbers and unique loci and samples
num.loc <- Dpop$LOCUS %>% unique %>% length
uniq.loc <- Dpop$LOCUS %>% unique
num.samp <- Dpop$SAMPLE %>% unique %>% length
uniq.samp <- Dpop$SAMPLE %>% unique
# Vector of missingness
num.miss <- rbinom(n=num.samp, size=num.loc, prob=pr)
# Iterate through samples and add unique loci
for(i in 1:num.samp){
locs <- sample(uniq.loc, size=num.miss[i], replace=FALSE)
Dpop[SAMPLE==uniq.samp[i] & LOCUS%in%locs, GT:=NA]
}
# Return
return(Dpop)
}
)
)
head(datGt, 10)
miss_plot_hist(datGt, plotBy='samples', look='ggplot')
#' Plot missing genotypes, by samples
#'
#' Use to visualise missing data with respect to samples and
#' their associated populations.
#'
#' @param dat Data table: Contains genetic information and must have
#' the following columns,
#' \enumerate{
#'   \item The sampled individuals (see param \code{sampCol}).
#'   \item The locus ID (see param \code{locusCol}).
#'   \item The genotype column, e.g. a genotype of allele frequency,
#'   (see param \code{genoCol}).
#' }
#'
#' @param plotBy Character: One of 'samples' or 'loci', the focus of missing data.
#'
#' @param look Character: The look of the plot. Default = \code{'ggplot'}, the
#' typical gray background with gridlines produced by \code{ggplot2}. Alternatively,
#' when set to \code{'classic'}, produces a base R style plot.
#'
#' @param sampCol Character: The column name with the sampled
#' individual ID. Default = \code{'SAMPLE'}.
#'
#' @param locusCol Character: The column name with the locus ID.
#' Default = \code{'LOCUS'}.
#'
#' @param genoCol Character: The column name with the genotype info.
#' Default = \code{'GT'}. Missing data should be represeted by \code{NA}.
#'
#' @param popCol Character: The column name with the population ID.
#' Optional parameter. Default = \code{NA}.
#'
#' @param plotColours Character: The fill colour for histogram bars.
#'
#' @param plotNCol Integer: The number of columns to arrange indiviudal
#' population plots into. Only takes effect when \code{popCol} is specified.
#' Default = 2.
#'
#' @details When \code{popCol} is unspecified, then all samples are used to create the plots.
#' If it is specified, then that column name is used to make one plot for
#' each population. These are arranged in rows and columns, and the
#' user can specify the number of columns with the argument \code{plotNCol}.
#'
#' @return Returns a ggplot object.
#'
#' @examples
#' library(genomalicious)
#'
#' ####   MISSING GENOTYPE DATA   ####
#' data(data_Genos)
#' datGt <- data_Genos
#'
#' # Add missing values
#' datGt <- do.call(
#'  'rbind',
#'  # Split data table by sample, and iterate through samples, X
#'  split(datGt, by='POP') %>%
#'    lapply(., function(Dpop){
#'      pop <- Dpop$POP[1]
#'
#'      if(pop=='Pop1'){
#'        pr <- 0.1
#'      } else if(pop=='Pop2'){
#'        pr <- 0.2
#'      } else if(pop %in% c('Pop3','Pop4')){
#'        pr <- 0.05
#'      }
#'
#'      # Numbers and unique loci and samples
#'      num.loc <- Dpop$LOCUS %>% unique %>% length
#'      uniq.loc <- Dpop$LOCUS %>% unique
#'      num.samp <- Dpop$SAMPLE %>% unique %>% length
#'      uniq.samp <- Dpop$SAMPLE %>% unique
#'
#'      # Vector of missingness
#'      num.miss <- rbinom(n=num.samp, size=num.loc, prob=pr)
#'
#'      # Iterate through samples and add unique loci
#'      for(i in 1:num.samp){
#'        locs <- sample(uniq.loc, size=num.miss[i], replace=FALSE)
#'        Dpop[SAMPLE==uniq.samp[i] & LOCUS%in%locs, GT:=NA]
#'      }
#'
#'      # Return
#'      return(Dpop)
#'    }
#'    )
#' )
#'
#' head(datGt, 10)
#'
#' ####   PLOT MISSING BY SAMPLES   ####
#' # Histograms, ggplot and classic looks
#' miss_plot_hist(datGt, plotBy='samples', look='ggplot')
#' miss_plot_hist(datGt, plotBy='samples',, look='classic')
#'
#' # Histograms, by population, specifying colour
#' miss_plot_hist(datGt, plotBy='samples',, look='ggplot'
#'                  , popCol='POP' , plotColours='deeppink2')
#'
#' ####   PLOT MISSING BY LOCI   ####
#' miss_plot_hist(datGt, plotBy='loci',, look='classic'
#'                  , popCol='POP' , plotColours='deeppink2')
#'
#' ####   CATCH PLOT OUTPUT FOR LATER USE   ####
#' gg4pops <- miss_plot_hist(datGt, plotBy='samples', popCol='POP')
#' plot(gg4pops)
#'
#' @export
miss_plot_hist <- function(
dat, plotBy, look='ggplot', sampCol='SAMPLE', locusCol='LOCUS', genoCol='GT',
popCol=NA, plotColours='white', plotNCol=2
){
# --------------------------------------------+
# Libraries, assertions, and setup
# --------------------------------------------+
for(lib in c('ggplot2', 'data.table','gridExtra')){ require(lib, character.only = TRUE)}
# Check that plotBy is specified properly
if(sum(c('samples', 'loci') %in% plotBy)!=1){
stop("Argument plotBy must be of length==1, and be either 'samples' or 'loci'.")
}
# A column specifier to focus data
if(plotBy=='samples'){ focus <- 'SAMPLE'
} else{ focus <- 'LOCUS' }
# Rename columns
colnames(dat)[
match(c(locusCol, genoCol, sampCol), colnames(dat))
] <- c('LOCUS', 'GT', 'SAMPLE')
# Rename the population column, if it was specified
if(is.na(popCol)==FALSE){
colnames(dat)[which(colnames(dat)==popCol)] <- 'POP'
}
# Set the plot theme by look
if(look=='ggplot'){
plotTheme <- theme_gray() + theme(legend.position='top'
, text=element_text(size=12))
} else if(look=='classic'){
plotTheme <- theme_bw() + theme(panel.grid.major=element_blank()
, panel.grid.minor=element_blank()
, text=element_text(colour='black', size=12)
, legend.position='top')
}
# --------------------------------------------+
# Code
# --------------------------------------------+
if(is.na(popCol)){
# If no population column is specified (NA)
stats <- dat[, sum(is.na(GT))/length(GT), by=focus]
gg <- (ggplot(stats, aes(x=V1))
+ plotTheme
+ geom_histogram(fill=plotColours[1], colour='black')
+ labs(x='Missing genotypes (%)'
, y=paste0('Number of ', plotBy)
))
} else{
# If population column is specified, facet plot by population
stats <- dat[, sum(is.na(GT))/length(GT), by=c(focus, 'POP')]
gg <- (ggplot(stats, aes(x=V1))
+ plotTheme + theme(strip.text.x=element_text(face='bold'))
+ geom_histogram(fill=plotColours[1], colour='black')
+ labs(x='Missing genotypes (%)'
, y=paste0('Number of ', plotBy))
+ facet_wrap(~ POP, ncol=plotNCol))
}
# Finish up
return(gg)
}
miss_plot_hist(datGt, plotBy='samples', look='ggplot')
dat <- data_Genos
sortBy='order'
chromCol='CHROM'
posCol='POS'
sampCol='SAMPLE'
genoCol='GT'
popCol=NA
plotColours='white'
plotNCol=2
# --------------------------------------------+
# Libraries, assertions, and setup
# --------------------------------------------+
for(lib in c('ggplot2', 'data.table','gridExtra')){ require(lib, character.only = TRUE)}
# Rename columns
colnames(dat)[
match(c(chromCol, posCol, genoCol, sampCol), colnames(dat))
] <- c('CHROM', 'POS', 'GT', 'SAMPLE')
# Create a list of loci
dat[, c('CHROM','POS')] %>%
unique %>%
setorder(., CHROM, POS) %>%
.[, paste0(CHROM, '_', POS)]
# Create a list of loci
uniq.loci <- dat[, c('CHROM','POS')] %>%
unique %>%
setorder(., CHROM, POS) %>%
.[, paste0(CHROM, '_', POS)]
uniq.loci
# Create a list of loci
uniq.loci <- dat[, c('CHROM','POS')] %>%
unique %>%
setorder(., CHROM, POS) %>%
.[, paste0(CHROM, '_', POS)]
dat[, LOCUS:=paste0(CHROM, '_', POS)]
dat[, LOCUS:=factor(LOCUS, levels=uniq.loci)]
# Create a list of loci
uniq.loci <- dat[, c('CHROM','POS')] %>%
unique %>%
setorder(., CHROM, POS) %>%
.[, paste0(CHROM, '_', POS)]
dat[, LOCUS:=paste0(CHROM, '_', POS)]
dat[, LOCUS:=factor(LOCUS, levels=uniq.loci)]
# Rename the population column, if it was specified
if(is.na(popCol)==FALSE){
colnames(dat)[which(colnames(dat)==popCol)] <- 'POP'
}
# Check that the sortBy is correctly specified.
if(sortBy!='order' | sortBy!='missing'){
stop('Argument `sortBy` must be one of "order" and "missing". See ?miss_plot_heatmap.')
}
sortBy='order'
# Check that the sortBy is correctly specified.
if(sortBy!='order' | sortBy!='missing'){
stop('Argument `sortBy` must be one of "order" and "missing". See ?miss_plot_heatmap.')
}
sortBy!='order'
sortBy!='missing'
sortBy!='order' | sortBy!='missing'
sortBy!='order'
sortBy!='order' | sortBy!='missing'
sortBy!='missing'
# Check that the sortBy is correctly specified.
check.sort <- sortBy %in% c('order','missing')
# Check that the sortBy is correctly specified.
check.sort <- sortBy %in% c('order','missing')
if(check.sort){
stop('Argument `sortBy` must be one of "order" and "missing". See ?miss_plot_heatmap.')
}
# Check that the sortBy is correctly specified.
check.sort <- sortBy %in% c('order','missing')
check.sort
if(check.sort!=TRUE){
stop('Argument `sortBy` must be one of "order" and "missing". See ?miss_plot_heatmap.')
}
stop('Argument `sortBy` must be one of "order" and "missing". See ?miss_plot_heatmap.')
# Assign a new column to record missing data
dat[, MISS:=as.integer(!is.na(GT))]
dat
dat[, sum(MISS)/length(LOCUS), by=LOCUS]
dat[, sum(MISS)/length(LOCUS), by=LOCUS]
dat
# Assign a new column to record missing data
dat[, MISS:=as.integer(is.na(GT))]
dat
dat[, sum(MISS)/length(LOCUS), by=LOCUS]
miss.levels <- dat[, sum(MISS)/length(LOCUS), by=LOCUS] %>%
setorder(., MISS) %>%
.[[LOCUS]]
miss.levels <- dat[, sum(MISS)/length(LOCUS), by=LOCUS] %>%
setorder(., V1) %>%
.[[LOCUS]]
miss.levels <- dat[, sum(MISS)/length(LOCUS), by=LOCUS] %>%
setorder(., V1) %>%
.[['LOCUS']]
miss.levels
# Sort
if(sortLoci=='order'){
dat[, LOCUS:=factor(LOCUS, levels=uniq.loci)]
} else if(sortLoci=='missing'){
miss.levels <- dat[, sum(MISS)/length(LOCUS), by=LOCUS] %>%
setorder(., V1) %>%
.[['LOCUS']]
dat[, LOCUS:=factor(LOCUS, levels=miss.level)]
}
dat <- datGt
# --------------------------------------------+
# Libraries, assertions, and setup
# --------------------------------------------+
for(lib in c('ggplot2', 'data.table','gridExtra')){ require(lib, character.only = TRUE)}
# Rename columns
colnames(dat)[
match(c(chromCol, posCol, genoCol, sampCol), colnames(dat))
] <- c('CHROM', 'POS', 'GT', 'SAMPLE')
# Create a list of loci
uniq.loci <- dat[, c('CHROM','POS')] %>%
unique %>%
setorder(., CHROM, POS) %>%
.[, paste0(CHROM, '_', POS)]
dat[, LOCUS:=paste0(CHROM, '_', POS)]
# Rename the population column, if it was specified
if(is.na(popCol)==FALSE){
colnames(dat)[which(colnames(dat)==popCol)] <- 'POP'
}
# Check that the sortLoci is correctly specified.
check.sort <- sortLoci %in% c('order','missing')
if(check.sort!=TRUE){
stop('Argument `sortLoci` must be one of "order" and "missing". See ?miss_plot_heatmap.')
}
# Make two colours, if only one specified
if(length(plotColours)<2){
plotColours <- c('white', 'royalblue')
} else if(length(plotColours)>2){
plotColours <- plotColours[1:2]
}
# Assign a new column to record missing data
dat[, MISS:=as.integer(is.na(GT))]
# Sort
if(sortLoci=='order'){
dat[, LOCUS:=factor(LOCUS, levels=uniq.loci)]
} else if(sortLoci=='missing'){
miss.levels <- dat[, sum(MISS)/length(LOCUS), by=LOCUS] %>%
setorder(., V1) %>%
.[['LOCUS']]
dat[, LOCUS:=factor(LOCUS, levels=miss.level)]
}
sortLoci <- 'locus'
dat[, LOCUS:=factor(LOCUS, levels=uniq.loci)]
# Sort
if(sortLoci=='order'){
dat[, LOCUS:=factor(LOCUS, levels=uniq.loci)]
} else if(sortLoci=='missing'){
miss.levels <- dat[, sum(MISS)/length(LOCUS), by=LOCUS] %>%
setorder(., V1) %>%
.[['LOCUS']]
dat[, LOCUS:=factor(LOCUS, levels=miss.levels)]
}
# If no population column is specified (NA)
gg <- (ggplot(dat, aes(x=SAMPLE, y=LOCUS))
+ geom_tile(aes(fill=as.factor(MISS)), colour=NA)
+ scale_fill_manual(values=c('0'=plotColours[1], '1'=plotColours[2]))
+ labs(x='Samples', y='Locus')
+ theme(
axis.text.x = element_blank()
,axis.text.y = element_blank()
,axis.ticks = element_blank()
,panel.border=element_rect(fill=NA, colour='black')
,panel.background=element_blank()
,panel.grid=element_blank()
,legend.position='none'
)
)
gg
