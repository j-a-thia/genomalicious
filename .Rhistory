expand=c(0,0)
)
+ scale_y_discrete(
expand=c(0,0)
)
+ labs(x='Alignment position', y='Taxa', fill=NULL)
)
# If base values desired
if(show_residues==TRUE){
alignGG <- alignGG + geom_text(mapping=aes(label=X), size=residue_size)
}
# If the legend should be removed
if(show_legend==FALSE){
alignGG <- alignGG + theme(legend.position='none')
}
# Output
return(alignGG)
}
pos_vec=200:210,
)
fasta <- paste0(genomaliciousExtData, '/data_COI_aa.fasta')
# Multi sequence alignmnet of demo COI data.
aln <- align_many_genes_aa(fasta, gene.names='COI')
# Plot base positions from 200:210
align_plot_aa(as.matrix(aln$COI$align), pos_vec=200:210)
# Custom colours, no text
align_plot_aa(
as.matrix(aln$COI$align),
pos_vec=200:210,
show_residues=FALSE
)
align_plot_aa(
as.matrix(aln$COI$align),
aa_colours=c(
# Small non-polar
'G'='#F8C641','A'='#F8C641','S'='#F8C641','T'='#F8C641',
# Hydrophobic
'C'='grey50','V'='grey50','I'='grey50','L'='grey50','P'='grey50','F'='grey50','Y'='grey50','M'='grey50','W'='grey50',
# Polar
'N'='#08c7e0','Q'='#08c7e0','H'='#08c7e0',
# Negatively charged
'D'='#ce0073','E'='#ce0073',
# Positively charged
'K'='#59A3FF','R'='#59A3FF'
)
pos_vec=200:210,
align_plot_aa(
as.matrix(aln$COI$align),
aa_colours=c(
# Small non-polar
'G'='#F8C641','A'='#F8C641','S'='#F8C641','T'='#F8C641',
# Hydrophobic
'C'='grey50','V'='grey50','I'='grey50','L'='grey50','P'='grey50','F'='grey50','Y'='grey50','M'='grey50','W'='grey50',
# Polar
'N'='#08c7e0','Q'='#08c7e0','H'='#08c7e0',
# Negatively charged
'D'='#ce0073','E'='#ce0073',
# Positively charged
'K'='#59A3FF','R'='#59A3FF'
),
pos_vec=200:210,
show_bases=FALSE
)
align_plot_aa(
as.matrix(aln$COI$align),
aa_colours=c(
# Small non-polar
'G'='#F8C641','A'='#F8C641','S'='#F8C641','T'='#F8C641',
# Hydrophobic
'C'='grey50','V'='grey50','I'='grey50','L'='grey50','P'='grey50','F'='grey50','Y'='grey50','M'='grey50','W'='grey50',
# Polar
'N'='#08c7e0','Q'='#08c7e0','H'='#08c7e0',
# Negatively charged
'D'='#ce0073','E'='#ce0073',
# Positively charged
'K'='#59A3FF','R'='#59A3FF'
),
pos_vec=200:210,
show_residues=FALSE
)
# Default colours, no text
align_plot_aa(
as.matrix(aln$COI$align),
aa_colours=c(
# Small non-polar
'G'='#F8C641','A'='#F8C641','S'='#F8C641','T'='#F8C641',
# Hydrophobic
'C'='grey80','V'='grey80','I'='grey80','L'='grey80','P'='grey80','F'='grey80','Y'='grey80','M'='grey80','W'='grey80',
# Polar
'N'='#08c7e0','Q'='#08c7e0','H'='#08c7e0',
# Negatively charged
'D'='#ce0073','E'='#ce0073',
# Positively charged
'K'='#59A3FF','R'='#59A3FF'
),
pos_vec=200:210,
show_residues=FALSE
)
border_colour='grey20',
align_plot_aa(
as.matrix(aln$COI$align),
aa_colours=c(
# Small non-polar
'G'='#F8C641','A'='#F8C641','S'='#F8C641','T'='#F8C641',
# Hydrophobic
'C'='grey80','V'='grey80','I'='grey80','L'='grey80','P'='grey80','F'='grey80','Y'='grey80','M'='grey80','W'='grey80',
# Polar
'N'='#08c7e0','Q'='#08c7e0','H'='#08c7e0',
# Negatively charged
'D'='#ce0073','E'='#ce0073',
# Positively charged
'K'='#59A3FF','R'='#59A3FF'
),
border_colour='grey20',
pos_vec=200:210,
show_residues=FALSE
)
fasta <- paste0(genomaliciousExtData, '/data_COI_dna.fasta')
# Multi sequence alignmnet of demo COI data.
aln <- align_many_genes_dna(fasta, gene.names='COI')
# Plot base positions from 598 to 608
align_plot_dna(as.matrix(aln$COI$align), pos_vec=598:608)
# Custom colours, no text, and borders
align_plot_dna(
as.matrix(aln$COI$align),
nuc_colours=c(`A`='#ce0073',`T`='#e46adf',`G`='#59A3FF',`C`='#08c7e0'),
border_colour='grey20',
pos_vec=598:608,
show_bases=FALSE
)
align_plot_dna(as.matrix(aln$COI$align), pos_vec=598:608)
fasta <- paste0(genomaliciousExtData, '/data_COI_aa.fasta')
# Multi sequence alignmnet of demo COI data.
aln <- align_many_genes_aa(fasta, gene.names='COI')
# Plot base positions from 200:210
align_plot_aa(as.matrix(aln$COI$align), pos_vec=200:210)
seq(598, 700, 3)
seq(598, 700, 3)[1:10]
align_plot_dna(as.matrix(aln$COI$align), pos_vec=598:627)
fasta <- paste0(genomaliciousExtData, '/data_COI_dna.fasta')
aln <- align_many_genes_dna(fasta, gene.names='COI')
align_plot_dna(as.matrix(aln$COI$align), pos_vec=598:627)
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyverse')
for(L in libs){require(L, character.only=TRUE)}
# Make all documents
roxygenise(clean=TRUE)
# Make just those documents that have changed
roxygenise()
library(genomalicious)
library(genomalicious)
# Create a link to raw external datasets in genomalicious
genomaliciousExtData <- paste0(find.package('genomalicious'), '/extdata')
# Path to the demo FASTA file
fasta <- paste0(genomaliciousExtData, '/data_COI_aa.fasta')
# Multi sequence alignmnet of demo COI data.
aln <- align_many_genes_aa(fasta, gene.names='COI')
# Plot base positions from 200:210
align_plot_aa(as.matrix(aln$COI$align), pos_vec=200:210)
# Default colours, no text, and borders
align_plot_aa(
as.matrix(aln$COI$align),
aa_colours=c(
# Small non-polar
'G'='#F8C641','A'='#F8C641','S'='#F8C641','T'='#F8C641',
# Hydrophobic
'C'='grey80','V'='grey80','I'='grey80','L'='grey80','P'='grey80','F'='grey80','Y'='grey80','M'='grey80','W'='grey80',
# Polar
'N'='#08c7e0','Q'='#08c7e0','H'='#08c7e0',
# Negatively charged
'D'='#ce0073','E'='#ce0073',
# Positively charged
'K'='#59A3FF','R'='#59A3FF'
),
border_colour='grey20',
pos_vec=200:210,
show_residues=FALSE
)
align_plot_aa(as.matrix(aln$COI$align), pos_vec=200:210)
library(genomalicious)
library(genomalicious)
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyverse')
for(L in libs){require(L, character.only=TRUE)}
# Make just those documents that have changed
roxygenise()
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyverse')
for(L in libs){require(L, character.only=TRUE)}
# Make just those documents that have changed
roxygenise()
library(genomalicious)
# Make all documents
roxygenise(clean=TRUE)
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyverse')
for(L in libs){require(L, character.only=TRUE)}
# Make just those documents that have changed
roxygenise()
library(genomalicious)
library(genomalicious)
genomaliciousExtData <- paste0(find.package('genomalicious'), '/extdata')
list.files(path=genomaliciousExtData, pattern='indseq.vcf')
vcfPath <- paste0(genomaliciousExtData, '/data_indseq.vcf')
readLines(vcfPath) %>%  head
readLines(vcfPath) %>%  tail
readVcf1 <- vcf2DT(vcfFile=vcfPath)
readVcf1
readVcf1
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyverse')
for(L in libs){require(L, character.only=TRUE)}
# Make just those documents that have changed
roxygenise()
library(genomalicious)
library(data.table)
getDTthreads()
genomaliciousExtData <- paste0(find.package('genomalicious'), '/extdata')
list.files(path=genomaliciousExtData, pattern='indseq.vcf')
vcfPath <- paste0(genomaliciousExtData, '/data_indseq.vcf')
readLines(vcfPath) %>%  head
library(genomalicious)
readLines(vcfPath) %>%  head
readLines(vcfPath) %>%  tail
vcfFile=vcfPath
dropCols=NULL
keepComments=FALSE
keepInfo=FALSE
# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
# #### Libraries and assertions            ####
# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
require(data.table); require(tidyverse)
# What is the position of the column heads?
n <- 1
headPos <- NULL
while(length(headPos)==0){
headPos <- grep('#CHROM', readLines(vcfFile, n=n), value=FALSE)
if(length(headPos)==0){
n <- n + 1000
}
}
# Read file from header
cat('(1/4) Reading in VCF as a data table', sep='\n')
vcfDT <- fread(vcfFile, skip=headPos-1, sep='\t', header=TRUE)
# Adjust header
colnames(vcfDT) <- gsub(pattern='#', replace='', x=colnames(vcfDT))
# Generate a $LOCUS column, place at the start of the data table
cat('(2/4) Generating locus IDs', sep='\n')
vcfDT <- vcfDT[, paste(CHROM, POS, sep='_')] %>%
data.table(LOCUS=., vcfDT)
# Get the locus info as a vector and drop from data table
if(keepInfo==TRUE){
vcfInfo <- vcfDT$INFO
names(vcfInfo) <- vcfDT$LOCUS
}
vcfDT <- vcfDT[, !'INFO']
# Which columns are the sample? The ones after the FORMAT column.
sampCols <- (which(colnames(vcfDT)=='FORMAT')+1):ncol(vcfDT)
cat('(3/4) Converting from wide to long format', sep='\n')
vcfDT <- data.table::melt(
data=vcfDT,
id.vars=1:(sampCols[1]-1),
measure.vars=sampCols,
variable.name='SAMPLE',
value.name='DATA') %>%
as.data.table()
# Make sure SAMPLE is a character
vcfDT[, SAMPLE:=as.character(SAMPLE)]
# Separate out the FORMAT data components into their own columns
cat('(4/4) Parsing data for each sample', sep='\n')
vcfDT
unlist(strsplit(vcfDT$FORMAT[1], split=':'))
# ... Get the format names
formatNames <- unlist(strsplit(vcfDT$FORMAT[1], split=':'))
# ... If the $DATA column is '.', add in NA
vcfDT[DATA=='.', DATA:=NA]
vcfDT
tstrsplit(DATA, ':', names=formatNames)
vcfDT %>% .[, tstrsplit(DATA, ':', names=formatNames)]
vcfDT[, tstrsplit(DATA, ':', names=formatNames)]
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyverse')
for(L in libs){require(L, character.only=TRUE)}
# Make just those documents that have changed
roxygenise()
library(genomalicious)
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyverse')
for(L in libs){require(L, character.only=TRUE)}
# Make just those documents that have changed
roxygenise()
library(genomalicious)
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyverse')
for(L in libs){require(L, character.only=TRUE)}
# Make just those documents that have changed
roxygenise()
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyverse')
for(L in libs){require(L, character.only=TRUE)}
# Make just those documents that have changed
roxygenise()
library(genomalicious)
#' Generate an allele frequency data table
#'
#' Takes a data.table of genotypes or allele counts and calculates the allele
#' frequency for each allele. Can be used for multiallelic datasets.
#'
#' @param dat Data.table: Long-format data table of variants, e.g., as read in
#' with \code{genomalicious::vcf2DT}.
#'
#' @param type Character: Two modes, one of "genos" for individual genotype data,
#' or "counts" of allele in populations.
#'
#' @param sampCol Character: The column with sample ID information. Default is "SAMPLE".
#' Only needed if \code{type=="genos"}.
#'
#' @param popCol Character: The column with population ID information. Default is "POP".
#'
#' @param locusCol Character: The column with locus ID information. Default is "LOCUS".
#'
#' @param genoCol Character: The column with genotype information. Default is "GT".
#' Only needed if \code{type=="genos"}. Genotypes must be in character format where
#' alleles are separated by the delimiter, "/". For example, "0/1" is one Ref and
#' one Alt allele 1; "2/2" is two Alt allele 2.
#'
#' @param countCol Character: The column with allele count information for all alleles.
#' For example, in pool-seq of populations, the number of read counts for each allele.
#' Default is "COUNTS". Only needed if \code{type=="counts"}. Counts should be separated
#' by commas, with the Ref allele first. E.g., "20,60,4" would indicate 20, 60, and 4
#' counts of the Ref allele, Alt allele 1, and Alt allele 2, respectively.
#'
#' @param indsCol Character: The column with the number of sampled individuals per
#' population. Default is "INDS".
#'
#' @details This function assumes no missing values. For \code{type=="genos"}, all
#' sampled individuals must have a genotype value for each locus.
#' For \code{type=="counts"}, all sampled populations must have count data for each
#' locus. You could impute for individuals, or drop loci with missing data for
#' for individual or population datasets.
#'
#' Note, when \code{type=="counts"}, the allele frequencies are based on the
#' proportion of counts per allele relative to the total number of observed counts
#' at a locus. However, this function will align the total sample number of
#' sequenced individuals against the counts.
#'
#' Note, when \code{type=="genos"}, heterozygosity is calculated assuming the
#' studied organism is a diploid.
#'
#' @returns Returns a long format data table with the following columns:
#' \enumerate{
#'  \item \code{$POP}, the population ID column.
#'  \item \code{$LOCUS}, the locus ID column.
#'  \item \code{$ALLELE}, the allele ID column (0 is Ref, and each subsequent
#'  Alt allele is 1 -> n alleles).
#'  \item \code{$COUNTS}, the number of observations of the allele: the number of
#'  individuals for genotype data, or the number of counts (e.g., reads) for
#'  population count data.
#'  \item \code{$INDS}, the number of individuals sampled per population.
#'  \item \code{$FREQ}, the estimated allele frequency.
#'  \item \code{$HET}, the proportion of heterozygotes, only output when \code{type=="genos"}.
#' }
#'
#' @examples
#' library(genomalicious)
#'
#' # Import biallelic SNPs as genotypes or population counts
#' data(data_Genos)
#' data(data_PoolFreqs)
#'
#' # On genotypes, convert the $GT values to characters.
#' dat_gt <- data_Genos %>%
#'   copy %>%
#'   .[, GT:=as.character(GT)] %>%
#'   .[GT==0, GT:='0/0'] %>%
#'   .[GT==1, GT:='0/1'] %>%
#'   .[GT==2, GT:='1/1']
#'
#' print(dat_gt)
#'
#' allele_freqs_DT(dat=dat_gt, type='genos')
#'
#' # On counts, need to make a $COUNTS column, and add in 30 individuals
#' # per locus per population in a new $INDS column.
#' dat_counts <- data_PoolFreqs %>%
#'   copy %>%
#'   .[, COUNTS:=paste(RO,AO,sep=',')] %>%
#'   .[, INDS:=30]
#'
#' print(dat_counts)
#'
#' allele_freqs_DT(dat=dat_counts, type='counts')
#' @export
allele_freqs_DT <- function(
dat, type, sampCol='SAMPLE', popCol='POP', locusCol='LOCUS',
genoCol='GT', countCol='COUNTS', indsCol='INDS'
){
# ----------------------------------------+
# ASSERTIONS + REFORMAT
# ----------------------------------------+
require(data.table); require(tidyverse)
# Check type
if(!type %in% c('genos','counts')){
stop('Argument `type` must be one of "genos" or "counts". See ?allele_freq_DT.')
}
# Check columns and reassign
if(type=='genos'){
check.cols <- c(sampCol,popCol,locusCol,genoCol) %in% colnames(dat)
if(length(check.cols)!=4){
stop('Argument `type`=="genos": At least one of `sampCol`, `popCol`, `locusSol`, or `genoCol` is not in `dat`. See ?allele_freq_DT.')
} else {
dat <- dat %>% copy %>% as.data.table %>%
setnames(
.,
old=c(sampCol,popCol,locusCol,genoCol),
new=c('SAMPLE','POP','LOCUS','GT')
)
}
} else if(type=='counts'){
check.cols <- c(popCol,locusCol,countCol,indsCol) %in% colnames(dat)
if(length(check.cols)!=4){
stop('Argument `type`=="freqs": At least one of `popCol`, `locusCol`, `countCol`, or `indsCol` is not in `dat`. See ?allele_freq_DT.')
} else{
dat <- dat %>% copy %>% as.data.table %>%
setnames(
.,
old=c(popCol,locusCol,countCol,indsCol),
new=c('POP','LOCUS','COUNTS','INDS')
)
}
}
# ----------------------------------------+
# MAIN CODE
# ----------------------------------------+
# Using genotypes or frequencies?
if(type=='genos'){
# Population information
pop.samps <- unique(dat[,c('POP','SAMPLE')])
pop.size <- pop.samps[, .(INDS=length(SAMPLE)), by=POP]
# Split the genotypes
dat.spl <- dat[, tstrsplit(GT,'/')] %>%
cbind(dat[, c('SAMPLE','LOCUS')], .)
# Heterozygote proportions per population and locus
het.tab <- dat.spl[, .(HET=sum(V1==V2)), by=c('SAMPLE','LOCUS')] %>%
left_join(., pop.samps) %>%
.[, .(HET=sum(HET)/length(SAMPLE)), by=c('POP','LOCUS')]
# Allele frequencies per population and locus
freq.tab <- data.table::melt(
dat.spl,
id.vars=c('SAMPLE','LOCUS'),
variable.name='VAR',
value.name='ALLELE'
) %>%
merge.data.table(., pop.samps, by.x='SAMPLE', by.y='SAMPLE') %>%
.[, .(COUNTS=length(VAR)), by=c('POP','LOCUS','ALLELE')]  %>%
merge.data.table(., pop.size, by.x='POP', by.y='POP') %>%
.[, FREQ:=COUNTS/(INDS*2)] %>%
setorder(., POP, LOCUS)
# Output
merge.data.table(
freq.tab, het.tab,
by.x=c('POP','LOCUS'), by.y=c('POP','LOCUS')
) %>% return()
} else if(type=='counts'){
# Population information
pop.sizes <- dat[, c('POP','INDS')] %>% unique
# Split the allele counts, then get allele frequencies as
# proportion of read counts.
dat[, tstrsplit(COUNTS, ',')] %>%
cbind(dat[, c('POP','LOCUS')], .) %>%
data.table::melt(
.,
id.vars=c('POP','LOCUS'),
variable.name='ALLELE',
value.name='COUNTS'
) %>%
setorder(., POP, LOCUS) %>%
.[!is.na(COUNTS)] %>%
.[, COUNTS:=as.integer(COUNTS)] %>%
.[, ALLELE:=as.integer(sub('V','',ALLELE))-1] %>%
.[, FREQ:=COUNTS/sum(COUNTS), by=c('POP','LOCUS')] %>%
merge.data.table(x=., y=pop.sizes, by.x='POP', by.y='POP') %>%
return()
}
}
library(genomalicious)
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyverse')
for(L in libs){require(L, character.only=TRUE)}
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyverse')
for(L in libs){require(L, character.only=TRUE)}
# Make just those documents that have changed
roxygenise()
# Make all documents
roxygenise(clean=TRUE)
library(genomalicious)
# Make all documents
roxygenise(clean=TRUE)
library(genomalicious)
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyverse')
for(L in libs){require(L, character.only=TRUE)}
# Make just those documents that have changed
roxygenise()
library(genomalicious)
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyverse')
for(L in libs){require(L, character.only=TRUE)}
# Make just those documents that have changed
roxygenise()
library(genomalicious)
