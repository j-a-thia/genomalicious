#' Filter loci based on their spacing
#'
#' A function to space loci based on a particular step size.
#' For each chromosome (contig), starting from the first locus, each
#' subsequent locus is assessed with respect to whether it is further
#' than the step size from the previous locus. If a locus is not >= the
#' step size, it will be skipped, and the next locus evaluated.
#' @param dat Data.table: Contains the information on the genomic context of each
#' locus, that is, their position and which chromosome/contig they reside on. You can
#' pass this function a genotype data.table (e.g., as produced from \code{vcf2DT()}),
#' because it will subset only the unique chromosome, position, and locus information.
#' Must contain the columns:
#' \enumerate{
#'    \item The chromosome/contig ID (see param \code{chromCol}).
#'    \item The positional information (see param \code{posCol}).
#'    \item The locus ID (see param \code{locusCol}).
#' }
#'
#' @param chromCol Character: The column name with the chromosome information.
#' Default = \code{'CHROM'}.
#'
#' @param posCol Character: The column name with the position information.
#' Default = \code{'POS'}.
#'
#' @param locusCol Character: The column name with the locus name information.
#' Default = \code{'LOCUS'}.
#'
#' @param stepSize Integer: the size of steps between loci.
#'
#' @returns Returns a vector of loci IDs to be kept.
#'
#' @export
filter_space_loci <- function(dat, chromCol='CHROM', posCol='POS', locusCol='LOCUS', stepSize){
# BEGIN ...........
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
require(data.table); require(tidyverse)
# Test that the data table is the correct class.
if(!'data.table' %in% class(dat)){
stop("Argument `dat` isn't a data table. See ?filter_space_loci.")
}
# Check for correct columns
if(sum(c(chromCol, posCol, locusCol) %in% colnames(dat))!=3){
stop("Not all specified columns (`chromCol`, `posCol`, `locusCol`) are in data.table dat. See ?filter_space_loci.")
}
# Check that the step size is a positive value
if(stepSize<1){
stop('Argument `stepSize` must be >=1. See ?filter_space_loci.')
}
# --------------------------------------------+
# Code
# --------------------------------------------+
# Rename columns
dat <- dat %>%
copy %>%
setnames(., c(chromCol, posCol, locusCol), c('CHROM','POS','LOCUS'))
# Get unique loci
D.uniq.loci <- dat[, c('CHROM','POS','LOCUS')] %>% unique()
# Iterate over chromosomes
D.keep.loci <- unique(D.uniq.loci$CHROM) %>%
lapply(., function(chrom){
# Subset the chormosome
D.chr.sub.loci <- D.uniq.loci[CHROM==chrom] %>%
setorder(., POS)
# Iterate over loci if more than 1 per contig
if(nrow(D.chr.sub.loci)>1){
# Default keep the first locus
D.chr.sub.loci[1, KEEP:=TRUE]
# Iterate through each subsequent locus, keep if >= stepSize from
# the previous locus.
for(i in 2:nrow(D.chr.sub.loci)){
pos.diff <- D.chr.sub.loci$POS[i] - D.chr.sub.loci$POS[i-1]
if(pos.diff >= stepSize){
D.chr.sub.loci$KEEP[i] <- TRUE
} else{
D.chr.sub.loci$KEEP[i] <- FALSE
}
}
# Output
D.chr.sub.loci
}
}) %>%
# Combine all chromosomes
do.call('rbind', .)
# Output
return(D.keep.loci[KEEP==TRUE]$LOCUS)
# ... END
}
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyverse')
for(L in libs){require(L, character.only=TRUE)}
# Make just those documents that have changed
roxygenise()
library(genomalicious)
library(polyRAD)
?RADdata
#' Convert a long-format data table into polyRAD's RADdata object class.
#'
#' Used to generate the RADdata class object from the \code{polyRAD} package
#' described in Clark et al. (2019).
#'
#' @param dat Data.table: A data table of read counts for genotypes loci.
#' Expects the columns:
#' \enumerate{
#'    \item The chromosome (contig) ID (see param \code{chromCol}).
#'    \item The position information (see param \code{posCol}).
#'    \item The locus ID (see param \code{locusCol}).
#'    \item The sample ID (see param \code{sampCol}).
#'    \item The reference allele nucleotides (see param \code{refCol}).
#'    \item The reference allele read counts (see param \code{roCol}).
#'    \item The alternate allele nucleotides (see param \code{altCol}).
#'    \item The alternate allele read counts (see param \code{aoCol}).
#'    (see param \code{freqCol})
#' }
#'
#' @param chromCol Character: The column name with the chromosome information.
#' Default = \code{'CHROM'}.
#'
#' @param posCol Character: The column name with the position information.
#' Default = \code{'POS'}.
#'
#' @param locusCol Character: The column name with the locus information.
#' Default = \code{'LOCUS'}.
#'
#' @param sampCol Character: The column name with the sampled individual information.
#' Default = \code{'SAMPLE'}. Only needed when \code{type=='genos'}.
#'
#' @param refCol Character: The column with the reference allele nucleotide information.
#' Default = \code{'REF'}.
#'
#' @param roCol Character: The column with the reference allele read count information.
#' Default = \code{'RO'}.
#'
#' @param altCol Character: The column with the alternate allele nucleotide information.
#' Default = \code{'ALT'}.
#'
#' @param aoCol Character: The column with the alternate allele read count information.
#' Default = \code{'AO'}.
#'
#' @param possPloidy List: A list of integers or numerics that represent the unique
#' ploidy values in the dataset. Default is \code{list(2)}, i.e., all samples have
#' a ploidy of 2. A list of \code{list(2, 4)} would represent possible ploidies of
#' 2 and 4.
#'
#' @param sampPloidy Integer/Numeric: Either a single value or a named vector of values
#' for each sample. Default is a single value, 2, i.e., all samples have a ploidy
#' of 2. A vector \code{c('Ind1'=2, 'Ind2'=4, 'Ind3'=2)}, for example, is a vector
#' of ploidies for three individuals, with ploidy values of 2, 4, and 2 for individuals 1, 2
#' and 3, respectively.
#'
#' @param contamRate Numeric: The contamination rate. Default is 0.001.
#'
#' @references Clark et al. (2019). G3. DOI: 10.1534/g3.118.200913
#'
#' @examples
#' library(genomalicious)
#' data(data_Genos)
#'
#' # Using a single ploidy
#' RD1 <- DT2RADdata(data_Genos, sampPloidy=2)
#'
#' # Using a vector of ploidies.
#' samps_uniq <- unique(data_Genos$SAMPLE)
#' samps_ploid <- rep(2, length(samps_uniq))
#' names(samps_ploid) <- samps_uniq
#'
#' samps_ploid
#'
#' RD2 <- DT2RADdata(data_Genos, sampPloidy=samps_ploid)
#'
#' Specifying multiple ploidies.
#' samps_ploid[20:40] <- 4
#'
#' samps_ploid %>% table
#'
#' RD3 <- DT2RADdata(data_Genos, possPloidy=list(2, 4), sampPloidy=samps_ploid)
DT2RADdata <- function(
dat, chromCol='CHROM', posCol='POS', locusCol='LOCUS', sampCol='SAMPLE',
refCol='REF', roCol='RO', altCol='ALT', aoCol='AO',
possPloidy=list(2L), sampPloidy=2L, contamRate=0.001){
# BEGIN ...........
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
library(data.table); library(polyRAD); library(tidyverse)
# Test that the data table is the correct class.
if(!'data.table' %in% class(dat)){
stop("Argument `dat` isn't a data table. See ?DT2RADdata.")
}
# Check columns are in dat
if(sum(c(chromCol, posCol, locusCol, sampCol, refCol, roCol, altCol, aoCol) %in% colnames(dat))!=8){
stop("Not all specified columns (`chromCol`, `posCol`, `locusCol`, `sampCol`, `refCol`, `roCol`, `altCol`, `aoCol`) are in data.table dat. See ?DT2RADdata.")
}
# Check that possible ploidies is a list
if(!'list' %in% class(possPloidy)){
stop('Argument `possPloidy` must be a "list" class object of integers. See ?DT2RADdata.')
}
# Check that sample ploidies are specified as in integer/numeric.
if(!class(sampPloidy) %in% c('numeric','integer')){
stop('Argument `sampPloidy` value must be an integer/numeric class. See ?DT2RADdata.')
}
# Check that sample ploidies are specified correctly as a named vector
if(length(sampPloidy)>1){
# Names present
if(is.null(names(sampPloidy))){
stop('Argument `sampPloidy` is specified as a vector, but sample names were not detected. See ?DT2RADdata.')
}
# All names match samples in dat
uniq_samps <- dat[[sampCol]] %>% unique
n_samps <- length(uniq_samps)
if(sum(uniq_samps %in% names(sampPloidy)) != n_samps){
stop('The samples in argument `dat` must all appear in the names in the argument `sampPloidy` if `sampPloidy` is specified as a vector. See ?DT2RADdata')
}
}
# --------------------------------------------+
# Code
# --------------------------------------------+
# Get the unique loci
uniqLociDt <- copy(dat[, c('LOCUS', 'CHROM', 'POS', 'REF', 'ALT')]) %>% unique()
setorder(uniqLociDt, 'CHROM', 'POS')
# Create allele names and number
uniqLociDt[, VAR.REF:=paste(LOCUS, REF, sep='_')]
uniqLociDt[, VAR.ALT:=paste(LOCUS, ALT, sep='_')]
uniqLociDt[, VAR.NUM:=1:nrow(uniqLociDt)]
# Get the unique samples
uniqSamps <- sort(unique(dat$SAMPLE))
# Create a matrix of allele read counts for each sample.
# Each locus is represented by two columns: one for the Ref
# allele, and another for the Alt allele counts.
# Therefore, for n samples and m loci, the dimensions of
# the matrix are n x 2m.
# Create unique alleles names for each locus
dat[, VAR.REF:=paste(LOCUS, REF, sep='_')]
dat[, VAR.ALT:=paste(LOCUS, ALT, sep='_')]
# Get the Ref and Alt observed read counts per allele.
# Loci will be in the same order in each of these wide data tables.
ro_wDT <- dcast(dat, SAMPLE ~ VAR.REF, value.var = 'RO')
ao_wDT <- dcast(dat, SAMPLE ~ VAR.ALT, value.var = 'AO')
# Convert to matrices
roMat <- ro_wDT %>%
column_to_rownames(var='SAMPLE') %>%
as.matrix()
aoMat <- ao_wDT %>%
column_to_rownames(var='SAMPLE') %>%
as.matrix()
# Replace NA with 0
roMat[is.na(roMat)] <- 0
aoMat[is.na(aoMat)] <- 0
# Make sure rownames in roMat and aoMat match
aoMat <- aoMat[match(rownames(roMat), rownames(aoMat)),]
# Make sure alleles are ordered by loci
roMat <- roMat[, uniqLociDt$VAR.REF]
aoMat <- aoMat[, uniqLociDt$VAR.ALT]
# Combine into single matrix and transform to integer class
depthMat <- apply(cbind(roMat, aoMat), 2, as.integer)
rownames(depthMat) <- rownames(roMat)
# Genetic info vectors
chrVec <- uniqLociDt$CHROM
posVec <- uniqLociDt$POS
locVec <- uniqLociDt$LOCUS
nucVec <- c(uniqLociDt$REF, uniqLociDt$ALT)
# Build RADdata object
rad_data <- RADdata(
alleleDepth=depthMat,
alleles2loc=c(1:ncol(roMat), 1:ncol(aoMat)),
locTable=data.frame(Chr=chrVec, Pos=posVec, row.names=locVec),
possiblePloidies=possPloidy,
contamRate=contamRate,
alleleNucleotides=nucVec,
taxaPloidy=sampPloidy
)
return(rad_data)
# ........ END
}
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyverse')
for(L in libs){require(L, character.only=TRUE)}
# Make just those documents that have changed
roxygenise()
library(genomalicious)
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyverse')
for(L in libs){require(L, character.only=TRUE)}
# Make just those documents that have changed
roxygenise()
library(genomalicious)
RD1 <- DT2RADdata(data_Genos, sampPloidy=2)
library(genomalicious)
data(data_Genos)
RD1 <- DT2RADdata(data_Genos, sampPloidy=2)
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyverse')
for(L in libs){require(L, character.only=TRUE)}
# Make just those documents that have changed
roxygenise()
library(genomalicious)
# Make all documents
roxygenise(clean=TRUE)
library(genomalicious)
library(genomalicious)
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyverse')
for(L in libs){require(L, character.only=TRUE)}
featureRef <- fread('00_Misc_data/mito_annot_features.csv')
featureRefs <- fread(paste(genomaliciousExtData, 'data_Bcocosensis_mito_features.csv', sep='/'))
genomaliciousExtData <- paste0(find.package('genomalicious'), '/extdata')
featureRefs <- fread(paste(genomaliciousExtData, 'data_Bcocosensis_mito_features.csv', sep='/'))
featureRefs <- fread(paste(genomaliciousExtData, 'data_Bcocosensis_mito_features.csv'), sep='/'))
paste0(genomaliciousExtData, 'data_Bcocosensis_mito_features.csv')
featureRefs <- fread(paste0(genomaliciousExtData, 'data_Bcocosensis_mito_features.csv')))
featureRefs <- fread(paste0(genomaliciousExtData, 'data_Bcocosensis_mito_features.csv'))
genomaliciousExtData <- paste0(find.package('genomalicious'), '/extdata')
paste0(genomaliciousExtData, 'data_Bcocosensis_mito_features.csv')
featureRefs <- fread(paste0(genomaliciousExtData, '/data_Bcocosensis_mito_features.csv'))
featureRefs <- fread(paste0(genomaliciousExtData, '/data_Bcocosensis_mito_features.csv'))
genomaliciousExtData <- paste0(find.package('genomalicious'), '/extdata')
genomaliciousExtData
genomaliciousExtData <- paste0(find.package('genomalicious'), '/extdata')
genomaliciousExtData
paste0(genomaliciousExtData, '/data_Bcocosensis_mito_features.csv')
"C:/Users/thiaj/AppData/Local/R/win-library/4.3/genomalicious/inst/extdata/data_Bcocosensis_mito_features.csv" -> featureRefs
featureRefs
bedFilePath <- fread(paste0(genomaliciousExtData, '/data_Bcocosensis_mito_annots.bed'))
bedFilePath <- paste0(genomaliciousExtData, '/data_Bcocosensis_mito_annots.bed')
bcocoFtRefs
bcocoFtRefs <- fread("C:/Users/thiaj/AppData/Local/R/win-library/4.3/genomalicious/inst/extdata/data_Bcocosensis_mito_features.csv")
# Make just those documents that have changed
roxygenise()
# Make just those documents that have changed
roxygenise()
library(genomalicious)
library(genomalicious)
genomaliciousExtData <- paste0(find.package('genomalicious'), '/extdata')
# genes from the Bathygobius cocosensis mitogenome.
bcocoFtRefs <- fread(paste0(genomaliciousExtData, '/data_Bcocosensis_mito_features.csv'))
bcocoBedPath <- paste0(genomaliciousExtData, '/data_Bcocosensis_mito_annots.bed')
bcocoFtRefs
bcocoBedPath
readLines(bcocoBedPath)
# Make just those documents that have changed
roxygenise()
library(genomalicious)
# Run
bed2featuretab(bcocoBedPath, bcocoFtRefs, 'Bcoco_feature_table.txt')
# Make all documents
roxygenise(clean=TRUE)
library(genomalicious)
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyverse')
for(L in libs){require(L, character.only=TRUE)}
library(Biostrings)
DNAStringSet('AA')
# Make just those documents that have changed
roxygenise()
library(genomalicious)
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyverse')
for(L in libs){require(L, character.only=TRUE)}
# Make just those documents that have changed
roxygenise()
library(genomalicious)
?assembly_correct_gaps
# Make just those documents that have changed
roxygenise()
?assembly_correct_gaps
library(genomalicious)
?assembly_correct_gaps
# Make just those documents that have changed
roxygenise()
library(genomalicious)
cat(i, '/', num_seqs)
library(genomalicious)
library(genomalicious)
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyverse')
for(L in libs){require(L, character.only=TRUE)}
# Make just those documents that have changed
roxygenise()
# Make just those documents that have changed
roxygenise()
library(genomalicious)
cat(i, '/', num_seqs, '\n')
#' Correct uneven gaps in an assembled genome
#'
#' Uneven gap sizes can form during genome assembly as different
#' assembling, polishing, and gap closing tools pile on top of each
#' other. This makes submission of a genome assembly problematic,
#' because varying gap sizes are ambiguous, and ideally we want unknown
#' gaps to have a standardised size. \cr\cr
#' This function takes a genome assembly and corrects gap sizes given
#' a user-define threshold. It is assumed that any gap larger than the
#' threshold is an unknown gap.
#'
#' @param genomeSS DNAStringSet: the genome assembly as a 'DNAStringSet'
#' object from the \code{Biostrings} package.
#'
#' @param threshold Integer: the minimum string of 'N's to consider a gap.
#'
#' @param correct Integer: the standardised number of 'N's for gaps of unknown size.
#' @returns Returns the genome assembly back as a DNAStringSet object with all
#' gaps meeting the threshold size standardized to the corrected size.
#' Sequences with corrected gaps are labelled with '_correct_gaps'.
#'
#' @export
assembly_correct_gaps <- function(genomeSS, threshold, correct){
require(Biostrings); require(data.table); require(doParallel); require(tidyverse)
# Quick checks
if(!'DNAStringSet' %in% class(genomeSS)){
stop('Argument `genomeSS` must be a "DNAStringSet" class. See ?assembly_correct_gaps.')
}
if(class(threshold)!='integer' | threshold<1){
stop('Argument `treshold` must be an "integer" class with a values >0. See ?assembly_correct_gaps.')
}
if(class(correct)!='integer' | correct<1){
stop('Argument `correct` must be an "integer" class with a values >0. See ?assembly_correct_gaps.')
}
# Iterate through each ith genomic sequence
resultsList <- list()
num_seqs <- length(genomeSS)
for(i in 1:num_seqs){
cat(i, '/', num_seqs, '\n')
require(Biostrings); require(data.table); require(tidyverse)
# Convert the sequence into a long-format data table
seq_i_tab <- genomeSS[i] %>%
as.matrix() %>%
t() %>%
as.data.table() %>%
setnames(., new='DNA')
# Add in an index and test whether the bases are Ns
seq_i_tab[, INDEX:=1:.N]
seq_i_tab[, IS.N:=DNA=='N']
# Subset and sort indexes with Ns. Gap IDs are currently unknown.
n_i_tab <- seq_i_tab[IS.N==TRUE] %>%
setorder(., INDEX) %>%
.[, GAP:=0L]
# Counter of unique gap IDs.
uniq_gap_count <- 1L
# Iterate through each jth index where there is an N.
# Test whether the jth index is exactly j+1 the previous index.
# If yes, then they are consecutive and part of the same gap.
# If no, then they are different gaps, and the counter goes up
for(j in 1:nrow(n_i_tab)){
if(j == 1){
n_i_tab$GAP[j] <- uniq_gap_count
} else if(j > 1){
index_j <- n_i_tab$INDEX[j]
index_j_m1 <- n_i_tab$INDEX[j-1]
index_consec <- index_j - 1 == (index_j_m1)
if(index_consec==TRUE){
n_i_tab$GAP[j] <- uniq_gap_count
} else if(index_consec==FALSE){
uniq_gap_count <- uniq_gap_count + 1
n_i_tab$GAP[j] <- uniq_gap_count
}
}
}
# Summarise the size of unique gaps
size_i_tab <- n_i_tab[, .(SIZE=length(INDEX)), by=GAP] %>%
.[, KEEP:=SIZE>=threshold]
keep_gaps_i <- size_i_tab[KEEP==TRUE]$GAP
# Return original sequence, or sequence with standardised gaps
if(nrow(size_i_tab)==0){
result_i <- genomeSS[i]
} else {
# The N string to replace corrected gaps
n_string <- paste(rep('N',correct), collapse='')
# Starting site for each gap
keep_i_tab <- n_i_tab[GAP %in% keep_gaps_i] %>%
copy %>%
.[, START:=INDEX==min(INDEX), by=GAP]
# Add in the info for the gaps to keep
seq_i_tab <- left_join(seq_i_tab, keep_i_tab, by=c('INDEX','IS.N'))
# Replace the string of the start site for each gap
seq_i_tab[!is.na(GAP) & START==TRUE, DNA:=n_string]
# Keep only sites that are 'A', 'T', 'G', 'C', or the first
# site for each gap. Make sure the sites are in order then
# paste them back together and convert into a string set.
new_seq_i <- seq_i_tab[is.na(GAP) | (!is.na(GAP) & START==TRUE)] %>%
setorder(., INDEX) %>%
.[['DNA']] %>%
paste(., collapse='') %>%
DNAStringSet()
# Add in the sequence name, but note that it is corrected.
names(new_seq_i) <- paste0(names(genomeSS[i]), '_correct_gaps')
# Add to results
result_i <- new_seq_i
}
# Cleanup and return results
gc()
resultsList[[i]] <- result_i
# End ith iteration
}
}
# Make just those documents that have changed
roxygenise()
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyverse')
for(L in libs){require(L, character.only=TRUE)}
# Make just those documents that have changed
roxygenise()
library(genomalicious)
library(genomalicious)
do.call('c', resultsList)
library(genomalicious)
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyverse')
for(L in libs){require(L, character.only=TRUE)}
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyverse')
for(L in libs){require(L, character.only=TRUE)}
library(genomalicious)
