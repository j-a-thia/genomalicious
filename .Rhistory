if(sum(c(X1, X2, Y) %in% colnames(dat))!=3){
stop('Argument `flip` is "TRUE", i.e., turn a pairwise data table into a
matrix, but not all the the required columns appear to be in `dat`.
Check parameterisation of `X1`, `X2`, and `Y`. See ?pairwiseMat2DT.')
}
}
)
pairMat <- pairwiseMat2DT(
dat=pairFst$genome, flip=TRUE, X1='POP1', X2='POP2', Y='FST'
)
pairMat
pairMat -> dat
dat
dat <- pairFst$genome
require(data.table); require(tidyverse)
if(flip==FALSE){
if(!'matrix' %in% class(dat)){
stop('Argument `dat` is not a matrix, but `type` is "FALSE", i.e.,
turn a pairwise matrix into a pairwise data table. See ?pairwiseMat2DT.')
}
}
flip=TRUE
if(flip==FALSE){
if(!'matrix' %in% class(dat)){
stop('Argument `dat` is not a matrix, but `type` is "FALSE", i.e.,
turn a pairwise matrix into a pairwise data table. See ?pairwiseMat2DT.')
}
}
if(flip==TRUE){
dat <- as.data.table(dat)
if(sum(c(X1, X2, Y) %in% colnames(dat))!=3){
stop('Argument `flip` is "TRUE", i.e., turn a pairwise data table into a
matrix, but not all the the required columns appear to be in `dat`.
Check parameterisation of `X1`, `X2`, and `Y`. See ?pairwiseMat2DT.')
}
}
samp.uniq <- rownames(dat)
samp.uniq
dat
dat
pairMat -> dat
samp.uniq <- rownames(dat)
output <- combn(samp.uniq, 2) %>%
t() %>%
as.data.table %>%
setnames(., new=c('X1','X2'))
output
for(i in 1:nrow(output)){
x1 <- output$X1[i]
x2 <- output$X2[i]
output$Y[i] <- dat[x1, x2]
}
output
setnames(output, old=c('X1','X2','Y'), new=c(X1,X2,Y))
output
flip=TRUE
dat <- pairFst$genome
dat
# Flipped: convert a pairiwse data table into matrix.
if(flip==TRUE){
samp.uniq <- c(dat[[X1]], dat[[X2]]) %>%  unique() %>%  sort()
n <- length(samp.uniq)
output <- matrix(0, ncol=n, nrow=n, dimnames=list(samp.uniq, samp.uniq))
for(i in 1:nrow(dat)){
x1.i <- dat[[X1]][i]
x2.i <- dat[[X2]][i]
measure.i <- dat[[Y]][[i]]
output[x1.i, x2.i] <- measure.i
output[x2.i, x1.i] <- measure.i
}
}
output
samp.uniq <- c(dat[[X1]], dat[[X2]]) %>%  unique() %>%  sort()
samp.uniq
dat
dat
dat %>%
dcast(., POP1 ~ POP2, value.var='FST')
dat <- pairFst$genome
dat
pairMat
pairMat -> dat
dat %>%
as.data.frame()
dat %>%
as.data.frame() %>%
rownames_to_column(., 'X1')
dat %>%
as.data.frame() %>%
rownames_to_column(., 'X1') %>%
melt(., id.vars='X1', variable.name='X2', value.var='Y')
dat %>%
as.data.frame() %>%
rownames_to_column(., 'X1') %>%
as.data.table %>%
melt(., id.vars='X1', variable.name='X2', value.var='Y')
dat %>%
as.data.frame() %>%
rownames_to_column(., 'X1') %>%
as.data.table %>%
melt(., id.vars='X1', variable.name='X2', value.name='Y')
dat %>%
as.data.frame() %>%
rownames_to_column(., 'X1') %>%
as.data.table %>%
melt(., id.vars='X1', variable.name='X2', value.name='Y') %>%
setnames(., old=c('X1','X2','Y'), new=c(X1,X2,Y))
output <- dat %>%
as.data.frame() %>%
rownames_to_column(., 'X1') %>%
as.data.table %>%
melt(., id.vars='X1', variable.name='X2', value.name='Y') %>%
setnames(., old=c('X1','X2','Y'), new=c(X1,X2,Y))
output
dat <- pairFst$genome
dat
dat
dat %>%
copy %>%
setnames(., old=c(X1,X2,Y), new=c('X1','X2','Y'))
dat <- dat %>%
copy %>%
setnames(., old=c(X1,X2,Y), new=c('X1','X2','Y'))
dat
samp.uniq <- dat[,c('X1','X2')] %>%
as.vector %>%
unique %>%
sort
dat[,c('X1','X2')] %>%
as.vector
dat[,c('X1','X2')]
samp.uniq <- dat[,c('X1','X2')] %>%
unlist %>%
unique %>%
sort
samp.uniq
rbind(
dat,
data.table(X1=dat$X2, X2=dat$X1, Y=dat$Y)
)
rbind(
dat,
data.table(X1=dat$X2, X2=dat$X1, Y=dat$Y),
data.table(X1=samp.uniq, X2=samp.uniq, Y=0)
)
rbind(
dat,
data.table(X1=dat$X2, X2=dat$X1, Y=dat$Y),
data.table(X1=samp.uniq, X2=samp.uniq, Y=0)
) %>%
dcast(., X1 ~ X2, value.var='Y')
rbind(
dat,
data.table(X1=dat$X2, X2=dat$X1, Y=dat$Y),
data.table(X1=samp.uniq, X2=samp.uniq, Y=0)
) %>%
dcast(., X1 ~ X2, value.var='Y') %>%
as.data.frame %>%
column_to_rownames(., 'X1')
rbind(
dat,
data.table(X1=dat$X2, X2=dat$X1, Y=dat$Y),
data.table(X1=samp.uniq, X2=samp.uniq, Y=0)
) %>%
dcast(., X1 ~ X2, value.var='Y') %>%
as.data.frame %>%
column_to_rownames(., 'X1') %>%
as.matrix()
#' Convert a pairwise matrix into a pairwise data table
#'
#' This function takes pairwise matrix (all possible combinations in rows and
#' columns) and converts it into a long-format data table. This function can
#' also be flipped, i.e., going from a pairwise data table to a pairwise matrix.
#'
#' @param dat Matrix or Data table: The default parameterisation (\code{flip==FALSE})
#' is expecting a pairwise matrix. This matrix needs to be symmetrical, with a
#' zero on the diagonal and the off-diagonal containing the measured variable
#' values between pairs. There should be row and column names. If instead you
#' want to go in the flipped parameterisation (\code{flip==TRUE}), then a
#' data table is expected, where pair combinations are represented into two
#' columns and the measured variable is in a third column.
#'
#' @param flip Logical: Should the function be flipped? Default is \code{FALSE},
#' a pairwise matrix should be converted into a pairwise data table. If set to
#' \code{TRUE}, then a pairwise data table is converted into a matrix.
#'
#' @param X1 Character: The column name for the first member of the pair.
#' If \code{flip==FALSE}, then \code{X1} will take the row names from the matrix
#' and put them into the first column of the output data table.
#' If \code{flip==TRUE}, then \code{X1} will be take the column in the data table and
#' put it as row names in the output matrix.
#'
#' @param X2 Character: The column name for the first member of the pair.
#' If \code{flip==FALSE}, then \code{X2} will take the column names from the matrix
#' and put them into the second column of the output data table.
#' If \code{flip==TRUE}, then \code{X2} will be take the column in the data table and
#' put it as column names in the output matrix.
#'
#' @param Y Character: The column name or the measured variable between pairs.
#' If \code{flip==FALSE}, then \code{Y} will take the values in the off-diagonal
#' in the matrix and put them into the third column of the output data table.
#' If \code{flip==TRUE}, then \code{Y} will be take the column in the data table and
#' put it as values in the off-diagonal in the output matrix.
#'
#' @examples
#' library(genomalicious)
#' data(data_Genos)
#'
#' # Calculate pairwise FST
#' pairFst <- fstat_calc(data_Genos, type='genos', fstat='FST', global=FALSE, pairwise=TRUE)
#'
#' # Convert into a pairwise matrix
#' pairMat <- pairwiseMat2DT(
#'    dat=pairFst$genome, flip=TRUE, X1='POP1', X2='POP2', Y='FST'
#' )
#' pairMat
#'
#' # Convert the pairwise matrix into a data table
#' pairDT <- pairwiseMat2DT(
#'    dat=pairMat, flip=FALSE, X1='POP1', X2='POP2', Y='FST'
#' )
#' pairDT
#'
#' @export
pairwiseMat2DT <- function(dat, flip=FALSE, X1, X2, Y){
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
require(data.table); require(tidyverse)
if(flip==FALSE){
if(!'matrix' %in% class(dat)){
stop('Argument `dat` is not a matrix, but `type` is "FALSE", i.e.,
turn a pairwise matrix into a pairwise data table. See ?pairwiseMat2DT.')
}
}
if(flip==TRUE){
dat <- as.data.table(dat)
if(sum(c(X1, X2, Y) %in% colnames(dat))!=3){
stop('Argument `flip` is "TRUE", i.e., turn a pairwise data table into a
matrix, but not all the the required columns appear to be in `dat`.
Check parameterisation of `X1`, `X2`, and `Y`. See ?pairwiseMat2DT.')
}
}
# --------------------------------------------+
# Code
# --------------------------------------------+
# Convert a pairwise matrix into a data table
if(flip==FALSE){
output <- dat %>%
as.data.frame() %>%
rownames_to_column(., 'X1') %>%
as.data.table %>%
melt(., id.vars='X1', variable.name='X2', value.name='Y') %>%
setnames(., old=c('X1','X2','Y'), new=c(X1,X2,Y))
}
# Flipped: convert a pairiwse data table into matrix.
if(flip==TRUE){
dat <- dat %>%
copy %>%
setnames(., old=c(X1,X2,Y), new=c('X1','X2','Y'))
samp.uniq <- dat[,c('X1','X2')] %>%
unlist %>%
unique %>%
sort
output <- rbind(
dat,
data.table(X1=dat$X2, X2=dat$X1, Y=dat$Y),
data.table(X1=samp.uniq, X2=samp.uniq, Y=0)
) %>%
dcast(., X1 ~ X2, value.var='Y') %>%
as.data.frame %>%
column_to_rownames(., 'X1')
}
# Output
return(output)
}
pairFst <- fstat_calc(data_Genos, type='genos', fstat='FST', global=FALSE, pairwise=TRUE)
pairMat <- pairwiseMat2DT(
dat=pairFst$genome, flip=TRUE, X1='POP1', X2='POP2', Y='FST'
)
pairMat
pairDT <- pairwiseMat2DT(
dat=pairMat, flip=FALSE, X1='POP1', X2='POP2', Y='FST'
)
pairDT
#' Convert a pairwise matrix into a pairwise data table
#'
#' This function takes pairwise matrix (all possible combinations in rows and
#' columns) and converts it into a long-format data table. This function can
#' also be flipped, i.e., going from a pairwise data table to a pairwise matrix.
#'
#' @param dat Matrix or Data table: The default parameterisation (\code{flip==FALSE})
#' is expecting a pairwise matrix. This matrix needs to be symmetrical, with a
#' zero on the diagonal and the off-diagonal containing the measured variable
#' values between pairs. There should be row and column names. If instead you
#' want to go in the flipped parameterisation (\code{flip==TRUE}), then a
#' data table is expected, where pair combinations are represented into two
#' columns and the measured variable is in a third column.
#'
#' @param flip Logical: Should the function be flipped? Default is \code{FALSE},
#' a pairwise matrix should be converted into a pairwise data table. If set to
#' \code{TRUE}, then a pairwise data table is converted into a matrix.
#'
#' @param X1 Character: The column name for the first member of the pair.
#' If \code{flip==FALSE}, then \code{X1} will take the row names from the matrix
#' and put them into the first column of the output data table.
#' If \code{flip==TRUE}, then \code{X1} will be take the column in the data table and
#' put it as row names in the output matrix.
#'
#' @param X2 Character: The column name for the first member of the pair.
#' If \code{flip==FALSE}, then \code{X2} will take the column names from the matrix
#' and put them into the second column of the output data table.
#' If \code{flip==TRUE}, then \code{X2} will be take the column in the data table and
#' put it as column names in the output matrix.
#'
#' @param Y Character: The column name or the measured variable between pairs.
#' If \code{flip==FALSE}, then \code{Y} will take the values in the off-diagonal
#' in the matrix and put them into the third column of the output data table.
#' If \code{flip==TRUE}, then \code{Y} will be take the column in the data table and
#' put it as values in the off-diagonal in the output matrix.
#'
#' @examples
#' library(genomalicious)
#' data(data_Genos)
#'
#' # Calculate pairwise FST
#' pairFst <- fstat_calc(data_Genos, type='genos', fstat='FST', global=FALSE, pairwise=TRUE)
#'
#' # Convert into a pairwise matrix
#' pairMat <- pairwiseMat2DT(
#'    dat=pairFst$genome, flip=TRUE, X1='POP1', X2='POP2', Y='FST'
#' )
#' pairMat
#'
#' # Convert the pairwise matrix into a data table
#' pairDT <- pairwiseMat2DT(
#'    dat=pairMat, flip=FALSE, X1='POP1', X2='POP2', Y='FST'
#' )
#' pairDT
#'
#' @export
pairwiseMat2DT <- function(dat, flip=FALSE, X1, X2, Y){
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
require(data.table); require(tidyverse)
if(flip==FALSE){
if(!'matrix' %in% class(dat)){
stop('Argument `dat` is not a matrix, but `type` is "FALSE", i.e.,
turn a pairwise matrix into a pairwise data table. See ?pairwiseMat2DT.')
}
}
if(flip==TRUE){
dat <- as.data.table(dat)
if(sum(c(X1, X2, Y) %in% colnames(dat))!=3){
stop('Argument `flip` is "TRUE", i.e., turn a pairwise data table into a
matrix, but not all the the required columns appear to be in `dat`.
Check parameterisation of `X1`, `X2`, and `Y`. See ?pairwiseMat2DT.')
}
}
# --------------------------------------------+
# Code
# --------------------------------------------+
# Convert a pairwise matrix into a data table
if(flip==FALSE){
output <- dat %>%
as.data.frame() %>%
rownames_to_column(., 'X1') %>%
as.data.table %>%
melt(., id.vars='X1', variable.name='X2', value.name='Y') %>%
setnames(., old=c('X1','X2','Y'), new=c(X1,X2,Y))
}
# Flipped: convert a pairiwse data table into matrix.
if(flip==TRUE){
dat <- dat %>%
copy %>%
setnames(., old=c(X1,X2,Y), new=c('X1','X2','Y'))
samp.uniq <- dat[,c('X1','X2')] %>%
unlist %>%
unique %>%
sort
output <- rbind(
dat,
data.table(X1=dat$X2, X2=dat$X1, Y=dat$Y),
data.table(X1=samp.uniq, X2=samp.uniq, Y=0)
) %>%
dcast(., X1 ~ X2, value.var='Y') %>%
as.data.frame %>%
column_to_rownames(., 'X1') %>%
as.matrix()
}
# Output
return(output)
}
# Calculate pairwise FST
pairFst <- fstat_calc(data_Genos, type='genos', fstat='FST', global=FALSE, pairwise=TRUE)
# Convert into a pairwise matrix
pairMat <- pairwiseMat2DT(
dat=pairFst$genome, flip=TRUE, X1='POP1', X2='POP2', Y='FST'
)
pairMat
pairDT <- pairwiseMat2DT(
dat=pairMat, flip=FALSE, X1='POP1', X2='POP2', Y='FST'
)
pairDT
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyverse')
for(L in libs){require(L, character.only=TRUE)}
# Make all documents
roxygenise(clean=TRUE)
library(genomalicious)
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyverse')
for(L in libs){require(L, character.only=TRUE)}
# Make just those documents that have changed
roxygenise()
library(genomalicious)
View(vcf2DT())
View(vcf2DT)
?separate
?tstrsplit()
genomaliciousExtData <- paste0(find.package('genomalicious'), '/extdata')
# This command here shows you the VCF file that comes with genomalicious
list.files(path=genomaliciousExtData, pattern='indseq.vcf')
# Use this to create a path to that file
vcfPath <- paste0(genomaliciousExtData, '/data_indseq.vcf')
vcfFile <- vcfPath
dropCols=NULL
keepComments=FALSE
keepInfo=
keepInfo=FALSE
keepInfo=FALSE
# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
# #### Libraries and assertions            ####
# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
require(data.table); require(tidyverse)
# What is the position of the header?
headPos <- grep('#CHROM', readLines(vcfFile), value=FALSE)
# Read file from header
cat('(1/4) Reading in VCF as a data table', sep='\n')
vcfDT <- fread(vcfFile, skip=headPos-1, sep='\t', header=TRUE)
# Adjust header
colnames(vcfDT) <- gsub(pattern='#', replace='', x=colnames(vcfDT))
# Generate a $LOCUS column, place at the start of the data table
cat('(2/4) Generating locus IDs', sep='\n')
vcfDT <- vcfDT[, paste(CHROM, POS, sep='_')] %>%
data.table(LOCUS=., vcfDT)
# Get the locus info as a vector and drop from data table
if(keepInfo==TRUE){
vcfInfo <- vcfDT$INFO
names(vcfInfo) <- vcfDT$LOCUS
}
vcfDT <- vcfDT[, !'INFO']
# Which columns are the sample? The ones after the FORMAT column.
sampCols <- (which(colnames(vcfDT)=='FORMAT')+1):ncol(vcfDT)
# Now convert the data from wide to long
cat('(3/4) Converting from wide to long format', sep='\n')
vcfDT <- melt(
data=vcfDT,
id.vars=1:(sampCols[1]-1),
measure.vars=sampCols,
variable.name='SAMPLE',
value.name='DATA')
# Make sure SAMPLE is a character
vcfDT[, SAMPLE:=as.character(SAMPLE)]
# Separate out the FORMAT data components into their own columns
cat('(4/4) Parsing data for each sample', sep='\n')
# ... Get the format names
formatNames <- unlist(strsplit(vcfDT$FORMAT[1], split=':'))
# ... If the $DATA column is '.', add in NA
vcfDT[DATA=='.', DATA:=NA]
vcfDT %>%
separate(col='DATA', into=formatNames, sep=':') %>%
as.data.table
formatNames
formatNames
vcfDT
vcfDT %>%
.[, tstrsplit(FORMAT, ':')] %>%
as.data.table
vcfDT
vcfDT %>%
.[, tstrsplit(DATA, ':')] %>%
as.data.table
vcfDT %>%
.[, tstrsplit(DATA, ':')] %>%
as.data.table %>%
setnames(., new=formatNames) %>%
print
vcfDT %>%
.[, tstrsplit(DATA, ':', keep=TRUE)] %>%
as.data.table
vcfDT %>%
.[, tstrsplit(DATA, ':', names=formatNames)]
vcfDT %>%
.[, tstrsplit(DATA, ':', names=formatNames)]
rbind(
vcfDT[, !c('FORMAT','DATA')]
vcfDT %>% .[, tstrsplit(DATA, ':', names=formatNames)]
cbind(
vcfDT[, !c('FORMAT','DATA')],
vcfDT %>% .[, tstrsplit(DATA, ':', names=formatNames)]
)
cbind(
vcfDT[, !c('FORMAT','DATA')],
vcfDT %>% .[, tstrsplit(DATA, ':', names=formatNames)]
) %>%
as.data.table()
library(genomalicious)
# Make just those documents that have changed
roxygenise()
library(genomalicious)
