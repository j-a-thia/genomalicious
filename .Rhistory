if(sum(names(plotColours) %in% pops.uniq)!=pops.k){
stop(
'For `type=="scatter"`, argument `plotColours` must be a named
character vector with all names matching the populations in
`dapcList$da.tab$POP`. See ?dapc_plot.'
)
}
}
}
if(type=='probs'){
# Population scale bar class
if(class(popBarScale)!='numeric'){
stop('Argument `popBarScale` must be a numeric value. See ?dapc_plot.')
}
# Population scale bar values
if(popBarScale<1){
stop('Argument `popBarScale` must be >=1. See ?dapc_plot.')
}
# Sample label class
if(class(sampleShow)!='logical'){
stop('Argument `sampleShow` must be a logical value. See ?dapc_plot.')
}
# Sample order class
if(!sampleOrder %in% c('by_id','by_probs')){
stop('Argument `sampleOrder` must be either "by_id" or "by_probs". See ?dapc_plot.')
}
# Check table
if(!'da.prob'%in%names(dapcList)){
stop(
'For `type=="probs"`, the argument `dapcList` needs the index
`dapcList$da.prob`. See ?dapc_plot.'
)
}
# Colours
if(!is.null(plotColours)){
pops.uniq <- dapcList$da.prob$POP %>% unique
pops.k <- length(pops.uniq)
if(sum(names(plotColours) %in% pops.uniq)!=pops.k){
stop(
'For `type=="probs"`, argument `plotColours` must be a named
character vector with all names matching the populations in
`dapcList$da.prob$POP`. See ?dapc_plot.'
)
}
}
}
if(type=='assign'){
if(!'pairs.long' %in% names(dapcList)){
stop('For `type==assign`, there must be index `dapcList$pairs.long`. See dapc_plot?')
}
if(!is.null(plotColours) & length(plotColours)<2){
stop('Argument `plotColours` requires 2 or more colours.')
}
if(is.null(plotColours)){
plotColours <- c('white', '#0030C1', '#D6012C')
}
}
# --------------------------------------------+
# Code
# --------------------------------------------+
### Plot scatter
if(type=='scatter'){
plot.tab <- dapcList$da.tab
# Get axes
axX <- paste0('LD',axisIndex[1])
axY <- paste0('LD',axisIndex[2])
# Percent explained variance
eigvals <- dapcList$da.fit$svd^2
varX <- round(eigvals[axisIndex[1]]/sum(eigvals) * 100, 2)
varY <- round(eigvals[axisIndex[2]]/sum(eigvals) * 100, 2)
# Create skeleton of plot
gg <- ggplot(plot.tab, aes_string(x=axX, y=axY, colour='POP')) +
plotTheme +
theme(legend.position=legendPos) +
geom_point() +
stat_ellipse(type='norm') +
labs(
x=paste0('LD', axisIndex[1], ' (', varX, '%)')
, y=paste0('LD', axisIndex[2], ' (', varY, '%)')
, colour=NULL
)
# Add points and population colours if specified
if(is.null(plotColours)==FALSE){
gg <- gg + scale_colour_manual(values=plotColours) + labs(colour=NULL)
}
}
### Plot probabilities
if(type=='probs'){
plot.tab <- dapcList$da.prob
# Should the samples be ordered by their posterior probabilities?
if(sampleOrder=='by_probs'){
samp.order <- plot.tab %>%
# Split by pop
split(., by='POP') %>%
# Iterate through pop, and order by probability
lapply(., function(D){
# The focal population
pop <- D$POP[1]
# Get the predictions for the focal population
D[POP.PRED==pop] %>%
# Organise in descending order
setorder(., -PROB) %>%
# Output the designated population and sample ID
.[, c('POP','SAMPLE')]
}) %>%
# Combine
do.call('rbind', .) %>%
# Add in an order ID
.[, ORDER:=1:.N]
} else if(sampleOrder=='by_id'){
samp.order <- plot.tab[, c('POP','SAMPLE')] %>%
unique() %>%
setorder(., POP, SAMPLE) %>%
.[, ORDER:=1:.N]
}
# Combine data with sample order
plot.tab <- left_join(plot.tab, samp.order) %>%
as.data.table %>%
setorder(., ORDER)
# Plot the populations
plot.pops <- left_join(
plot.tab[, .(MIN=(min(as.integer(ORDER)))-0.5), by=POP],
plot.tab[, .(MAX=(max(as.integer(ORDER)))+0.5), by=POP],
)
# Create skeleton of plot
gg <- ggplot() +
theme(
panel.border = element_blank(),
panel.background = element_blank(),
axis.text.x = element_text(angle=30, hjust=1),
axis.ticks.length.x = unit(1.5, 'mm'),
axis.ticks.length.y = unit(1.5, 'mm'),
legend.position=legendPos
) +
geom_col(
data=plot.tab,
mapping=aes(x=ORDER, y=PROB, fill=POP.PRED)
) +
geom_rect(
data=plot.pops,
mapping=aes(xmin=MIN, xmax=MAX, fill=POP),
ymax=-0.02,
ymin=-0.04*popBarScale,
inherit.aes=FALSE
) +
scale_x_continuous(
expand=c(0,0),
breaks=1:max(samp.order$ORDER),
labels=samp.order$SAMPLE
) +
scale_y_continuous(
expand=c(0,0),
limits=c(-0.04*popBarScale, 1.01)
) +
labs(x='Samples', y='Probability', fill=NULL)
# Add points and population colours if specified
if(is.null(plotColours)==FALSE){
gg <- gg + scale_fill_manual(values=plotColours) + labs(colour=NULL)
}
# Remove sample names if specified
if(sampleShow==FALSE){
gg <- gg + theme(
axis.text.x = element_blank(),
axis.ticks.x = element_blank()
)
}
}
### Plot assignment rates
if(type=='assign'){
plot.tab <- dapcList$pairs.long
gg <- ggplot(plot.tab, aes(x=POP, y=POP.PRED, fill=ASSIGN)) +
theme(
panel.border = element_blank(),
panel.background = element_blank(),
axis.ticks.length.x = unit(1.5, 'mm'),
axis.ticks.length.y = unit(1.5, 'mm'),
legend.position=legendPos
) +
geom_tile(colour='grey20') +
scale_x_discrete(expand=c(0,0)) +
scale_y_discrete(expand=c(0,0)) +
scale_fill_gradientn(
colours=plotColours,
guide = guide_colorbar(frame.colour = "grey20", ticks.colour = "grey20")
) +
labs(x='Observed', y='Predicted', fill='Assignment rate')
}
### Output
return(gg)
}
DAPC.fit <- dapc_fit(data_Genos, pcPreds=3, method='fit')
dapc_plot(DAPC.fit, type='probs')
dapc_plot(DAPC.fit, type='probs', sampleOrder = 'by_probs')
# Make just those documents that have changed
roxygenise()
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyverse')
for(L in libs){require(L, character.only=TRUE)}
# Make just those documents that have changed
roxygenise()
library(genomalicious)
#' DNA to a condon data.table
#'
#' Convert a DNA coding sequence into a data.table of codons and amino acids.
#'
#' @param cdsSeq Character = A DNA coding sequence.
#'
#' @param compressTab Logical = Should the table be compressed? Default is TRUE,
#' in which case, each row is a unique codon. If FALSE, then each codon is represented
#' by 3 rows, one for each nucleotide comprising the codon.
#'
#' @param geneticCode Integer = A value relating to the \code{numcode} argument in
#' \code{seqinr::translate}.
#'
#' @details Assumes that the sequence is in its correct reading frame, that is,
#' the first DNA nucleotide is the first base of the first codon.
#'
#' @return
#' Returns a data.table with the following columns:
#'
#' \enumerate{
#'    \item \code{$CODON} = The codon number, 1:N.
#'    \item \code{$NUC} = The nucleotides comprising the codon.
#'    \item \code{$AMINO} = The amino acid residue.
#'    \item \code{$DNA} = The DNA bases.
#' }
#'
#' @examples
#' X <- 'ATGCGTACTTCA'
#'
#' dna2codonDT(X, compressTab=TRUE)
#'
#' dna2codonDT(X, compressTab=FALSE)
#'
#' @export
dna2codonDT <- function(cds.seq){
require(data.table)
require(seqinr)
require(tidyverse)
# Split the sequence into codons
codonList <- seqinr::splitseq(
seq = cdsSeq  %>% as.character %>% s2c
)
# Iterate over ith the codons
codonTab <- lapply(1:length(codonList), function(i){
# Subset codon
cod <- codonList[i]
# Get the relative nucleotide positions within the codon
n <- length(codonList[1:i])*3
# Get the amino acid
amino <- seqinr::translate(cod %>% s2c, numcode=geneticCode)
# Make the table for this codon
if(compressTab==TRUE){
# Compressed table format
tab <- data.table(
CODON=i,
NUC=paste(n-2, n-1, n, sep='|'),
AMINO=amino,
DNA=cod
)
} else if(compressTab==FALSE){
# Uncompressed table format
tab <- data.table(
CODON=i,
NUC=c(n-2, n-1, n),
AMINO=amino,
DNA=cod
)
}
}) %>%
do.call('rbind',.)
# Output
codonTab %>% return()
}
#' @examples
X <- 'ATGCGTACTTCA'
dna2codonDT(X, compressTab=TRUE)
#' DNA to a condon data.table
#'
#' Convert a DNA coding sequence into a data.table of codons and amino acids.
#'
#' @param cdsSeq Character = A DNA coding sequence.
#'
#' @param compressTab Logical = Should the table be compressed? Default is TRUE,
#' in which case, each row is a unique codon. If FALSE, then each codon is represented
#' by 3 rows, one for each nucleotide comprising the codon.
#'
#' @param geneticCode Integer = A value relating to the \code{numcode} argument in
#' \code{seqinr::translate}.
#'
#' @details Assumes that the sequence is in its correct reading frame, that is,
#' the first DNA nucleotide is the first base of the first codon.
#'
#' @return
#' Returns a data.table with the following columns:
#'
#' \enumerate{
#'    \item \code{$CODON} = The codon number, 1:N.
#'    \item \code{$NUC} = The nucleotides comprising the codon.
#'    \item \code{$AMINO} = The amino acid residue.
#'    \item \code{$DNA} = The DNA bases.
#' }
#'
#' @examples
#' X <- 'ATGCGTACTTCA'
#'
#' dna2codonDT(X, compressTab=TRUE)
#'
#' dna2codonDT(X, compressTab=FALSE)
#'
#' @export
dna2codonDT <- function(cds.seq){
require(data.table)
require(seqinr)
require(tidyverse)
# Split the sequence into codons
codonList <- seqinr::splitseq(
seq = cdsSeq  %>% as.character %>% s2c
)
# Iterate over ith the codons
codonTab <- lapply(1:length(codonList), function(i){
# Subset codon
cod <- codonList[i]
# Get the relative nucleotide positions within the codon
n <- length(codonList[1:i])*3
# Get the amino acid
amino <- seqinr::translate(cod %>% s2c, numcode=geneticCode)
# Make the table for this codon
if(compressTab==TRUE){
# Compressed table format
tab <- data.table(
CODON=i,
NUC=paste(n-2, n-1, n, sep='|'),
AMINO=amino,
DNA=cod
)
} else if(compressTab==FALSE){
# Uncompressed table format
tab <- data.table(
CODON=i,
NUC=c(n-2, n-1, n),
AMINO=amino,
DNA=cod
)
}
}) %>%
do.call('rbind',.)
# Output
codonTab %>% return()
}
#' DNA to a condon data.table
#'
#' Convert a DNA coding sequence into a data.table of codons and amino acids.
#'
#' @param cdsSeq Character = A DNA coding sequence.
#'
#' @param compressTab Logical = Should the table be compressed? Default is TRUE,
#' in which case, each row is a unique codon. If FALSE, then each codon is represented
#' by 3 rows, one for each nucleotide comprising the codon.
#'
#' @param geneticCode Integer = A value relating to the \code{numcode} argument in
#' \code{seqinr::translate}.
#'
#' @details Assumes that the sequence is in its correct reading frame, that is,
#' the first DNA nucleotide is the first base of the first codon. Default is 1.
#'
#' @return
#' Returns a data.table with the following columns:
#'
#' \enumerate{
#'    \item \code{$CODON} = The codon number, 1:N.
#'    \item \code{$NUC} = The nucleotides comprising the codon.
#'    \item \code{$AMINO} = The amino acid residue.
#'    \item \code{$DNA} = The DNA bases.
#' }
#'
#' @examples
#' X <- 'ATGCGTACTTCA'
#'
#' dna2codonDT(X, compressTab=TRUE)
#'
#' dna2codonDT(X, compressTab=FALSE)
#'
#' @export
dna2codonDT <- function(cdsSeq, compressTab=FALSE, geneticCode=1){
require(data.table)
require(seqinr)
require(tidyverse)
# Split the sequence into codons
codonList <- seqinr::splitseq(
seq = cdsSeq  %>% as.character %>% s2c
)
# Iterate over ith the codons
codonTab <- lapply(1:length(codonList), function(i){
# Subset codon
cod <- codonList[i]
# Get the relative nucleotide positions within the codon
n <- length(codonList[1:i])*3
# Get the amino acid
amino <- seqinr::translate(cod %>% s2c, numcode=geneticCode)
# Make the table for this codon
if(compressTab==TRUE){
# Compressed table format
tab <- data.table(
CODON=i,
NUC=paste(n-2, n-1, n, sep='|'),
AMINO=amino,
DNA=cod
)
} else if(compressTab==FALSE){
# Uncompressed table format
tab <- data.table(
CODON=i,
NUC=c(n-2, n-1, n),
AMINO=amino,
DNA=cod
)
}
}) %>%
do.call('rbind',.)
# Output
codonTab %>% return()
}
dna2codonDT(X, compressTab=TRUE)
dna2codonDT(X, compressTab=FALSE)
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyverse')
for(L in libs){require(L, character.only=TRUE)}
# Make all documents
roxygenise(clean=TRUE)
library(genomalicious)
str_split('ATG', '')
strsplit('ATG', '')
strsplit('ATG', '')[[1]]
#' DNA to a condon data.table
#'
#' Convert a DNA coding sequence into a data.table of codons and amino acids.
#'
#' @param cdsSeq Character = A DNA coding sequence.
#'
#' @param compressTab Logical = Should the table be compressed? Default is TRUE,
#' in which case, each row is a unique codon. If FALSE, then each codon is represented
#' by 3 rows, one for each nucleotide comprising the codon.
#'
#' @param geneticCode Integer = A value relating to the \code{numcode} argument in
#' \code{seqinr::translate}.
#'
#' @details Assumes that the sequence is in its correct reading frame, that is,
#' the first DNA nucleotide is the first base of the first codon. Default is 1.
#'
#' @return
#' Returns a data.table with the following columns:
#'
#' \enumerate{
#'    \item \code{$CODON} = The codon number, 1:N.
#'    \item \code{$NUC} = The nucleotides comprising the codon.
#'    \item \code{$AMINO} = The amino acid residue.
#'    \item \code{$DNA} = The DNA bases.
#' }
#'
#' @examples
#' X <- 'ATGCGTACTTCA'
#'
#' dna2codonDT(X, compressTab=TRUE)
#'
#' dna2codonDT(X, compressTab=FALSE)
#'
#' @export
dna2codonDT <- function(cdsSeq, compressTab=FALSE, geneticCode=1){
require(data.table)
require(seqinr)
require(tidyverse)
# Split the sequence into codons
codonList <- seqinr::splitseq(
seq = cdsSeq  %>% as.character %>% s2c
)
# Iterate over ith the codons
codonTab <- lapply(1:length(codonList), function(i){
# Subset codon
cod <- codonList[i]
# Get the relative nucleotide positions within the codon
n <- length(codonList[1:i])*3
# Get the amino acid
amino <- seqinr::translate(cod %>% s2c, numcode=geneticCode)
# Make the table for this codon
if(compressTab==TRUE){
# Compressed table format
tab <- data.table(
CODON=i,
NUC=paste(n-2, n-1, n, sep='|'),
AMINO=amino,
DNA=cod
)
} else if(compressTab==FALSE){
# Uncompressed table format
tab <- data.table(
CODON=i,
NUC=c(n-2, n-1, n),
AMINO=amino,
DNA=strsplit('ATG', '')[[1]]
)
}
}) %>%
do.call('rbind',.)
# Output
codonTab %>% return()
}
dna2codonDT(X, compressTab=FALSE)
X <- 'ATGCGTACTTCA'
dna2codonDT(X, compressTab=TRUE)
dna2codonDT(X, compressTab=FALSE)
library(genomalicious)
