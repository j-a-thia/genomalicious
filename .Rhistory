#' of coverage, and the read count of the alterante allele. The reference allele read count
#' is assumed to be 1 - alternate allele read count.
#' Must contain the columns:
#' \enumerate{
#'    \item The sample ID (see param \code{sampCol}).
#'    \item The locus ID (see param \code{locusCol}).
#'    \item The total read depth (see param \code{dpCol}).
#'    \item The alternate allele read counts (see param \code{aoCol}).
#' }
#'
#' @param sampCol Character: The column with the sample information.
#' Default = \code{'SAMPLE'}.
#'
#' @param locusCol Character: The column with the locus information.
#' Default = \code{'LOCUS'}.
#'
#' @param dpCol Character: The column with the total read depth information.
#' Default = \code{'DP'}.
#'
#' @param aoCol Character: The column with the alternate allele read count information.
#' Default = \code{'AO'}.
#'
#' @param suppReads Integer: The minimum number of supporting reads for the allele that
#' is least well covered by reads within a sample.
#'
#' @details Note, this sample will only evaluate sites for each there are reads
#' supporting both alleles. It will not evaluate sites that only have reads for the
#' reference alleles, or only have reads for the alternate allele.
#'
#' @returns Returns a data.table with the columns \code{$SAMPLE} and \code{$LOCUS},
#' the sample and locus information, and \code{KEEP}, a logical column with TRUE or FALSE
#' indicating whether a sample + locus observation should be kept based on uncertainty
#' in the supporting reads. Note, all samples + loci observations are returned, such that
#' they will match \code{dat}. This facilitates merging of the original data and results.
#'
#' @examples
#' library(genomalicious)
#' data(data_Genos)
#'
#' # Take a look at the read distribution for alternate alleles
#' hist(data_Genos$AO, xlab='Alt allele read counts', main='')
#'
#' # Let's find those sample + loci observations where there are not
#' # at least 3 reads supporting each allele
#' supp3 <- filter_supporting_reads(data_Genos, suppReads=3)
#'
#' head(supp3)
#'
#' supp3[KEEP==FALSE]
#'
#' # You could use this information to filter loci. For example, removing
#' # a locus if any sample does not meet the supporting read threshold.
#' uniq_bad_loci <- unique(supp10[KEEP==FALSE]$LOCUS)
#'
#' data_Genos[!LOCUS %in% uniq_bad_loci]
#'
#' @export
filter_supporting_reads <- function(dat, sampCol='SAMPLE', locusCol='LOCUS', dpCol='DP', aoCol='AO', suppReads=3){
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
require(data.table); require(tidyverse)
# Test that the data table is the correct class.
if(!'data.table' %in% class(dat)){
stop("Argument `dat` isn't a data table. See ?filter_space_loci.")
}
# Check for correct columns
if(sum(c(sampCol, locusCol, dpCol, aoCol) %in% colnames(dat))!=4){
stop("Not all specified columns (`sampCol`, `locusCol`, `dpCol`, `aoCol`) are in data.table dat. See ?filter_space_loci.")
}
# Check that the supporting reads is a positive value
if(suppReads<1){
stop('Argument `stepSize` must be >=1. See ?filter_space_loci.')
}
# --------------------------------------------+
# Code
# --------------------------------------------+
# Rename columns
dat <- dat %>%
copy %>%
setnames(., c(sampCol, locusCol, dpCol, aoCol), c('SAMPLE','LOCUS','DP','AO')) %>%
.[, RO:=DP-AO]
# Output
dat[, ZYG:=if_else(DP==RO | DP==AO, 'Hom', 'Het')]
dat[ZYG=='Hom', KEEP:=TRUE]
dat[ZYG=='Het', KEEP:=if_else((RO<suppReads) & (AO<suppReads), FALSE, TRUE)]
return(dat[, c('SAMPLE','LOCUS','KEEP')])
}
supp3 <- filter_supporting_reads(data_Genos, suppReads=3)
supp3 <- filter_supporting_reads(data_Genos, suppReads=3)
supp3[KEEP==FALSE]
uniq_bad_loci <- unique(supp10[KEEP==FALSE]$LOCUS)
data_Genos[!LOCUS %in% uniq_bad_loci]
uniq_bad_loci <- unique(suppTest[KEEP==FALSE]$LOCUS)
suppTest <- filter_supporting_reads(data_Genos, suppReads=5)
head(suppTest)
suppTest[KEEP==FALSE]
uniq_bad_loci <- unique(suppTest[KEEP==FALSE]$LOCUS)
uniq_bad_loci
data_Genos[!LOCUS %in% uniq_bad_loci]
#' Filter samples by the minimum supporting reads for alleles.
#'
#' This function can almost be seen like a minor allele frequency or count filter
#' at the level of a the sample (instead of the whole dataset). It will mark
#' a sample as having insufficient supporting reads for the allele with lower coverage
#' if they are below a certain threshold. This might be useful, for example, when
#' using pooled allele frequencies, or when genotypes individuals are sequenced at
#' low-to-moderate coverage.
#'
#' @param dat Data.table: Contains the information of samples, loci, the total depth
#' of coverage, and the read count of the alterante allele. The reference allele read count
#' is assumed to be 1 - alternate allele read count.
#' Must contain the columns:
#' \enumerate{
#'    \item The sample ID (see param \code{sampCol}).
#'    \item The locus ID (see param \code{locusCol}).
#'    \item The total read depth (see param \code{dpCol}).
#'    \item The alternate allele read counts (see param \code{aoCol}).
#' }
#'
#' @param sampCol Character: The column with the sample information.
#' Default = \code{'SAMPLE'}.
#'
#' @param locusCol Character: The column with the locus information.
#' Default = \code{'LOCUS'}.
#'
#' @param dpCol Character: The column with the total read depth information.
#' Default = \code{'DP'}.
#'
#' @param aoCol Character: The column with the alternate allele read count information.
#' Default = \code{'AO'}.
#'
#' @param suppReads Integer: The minimum number of supporting reads for the allele that
#' is least well covered by reads within a sample.
#'
#' @details Note, this sample will only evaluate sites for each there are reads
#' supporting both alleles. It will not evaluate sites that only have reads for the
#' reference alleles, or only have reads for the alternate allele.
#'
#' @returns Returns a data.table with the columns \code{$SAMPLE} and \code{$LOCUS},
#' the sample and locus information, and \code{KEEP}, a logical column with TRUE or FALSE
#' indicating whether a sample + locus observation should be kept based on uncertainty
#' in the supporting reads. Note, all samples + loci observations are returned, such that
#' they will match \code{dat}. This facilitates merging of the original data and results.
#'
#' @examples
#' library(genomalicious)
#' data(data_Genos)
#'
#' # Take a look at the read distribution for alternate alleles
#' hist(data_Genos$AO, xlab='Alt allele read counts', main='')
#'
#' # Let's find those sample + loci observations where there are not
#' # at least 5 reads supporting each allele
#' suppTest <- filter_supporting_reads(data_Genos, suppReads=5)
#'
#' head(suppTest)
#'
#' suppTest[KEEP==FALSE]
#'
#' # You could use this information to filter loci. For example, removing
#' # a locus if any sample does not meet the supporting read threshold for
#' # both alleles.
#' uniq_bad_loci <- unique(suppTest[KEEP==FALSE]$LOCUS)
#'
#' uniq_bad_loci
#'
#' data_Genos[!LOCUS %in% uniq_bad_loci]
#'
#' @export
filter_supporting_reads <- function(dat, sampCol='SAMPLE', locusCol='LOCUS', dpCol='DP', aoCol='AO', suppReads=3){
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
require(data.table); require(tidyverse)
# Test that the data table is the correct class.
if(!'data.table' %in% class(dat)){
stop("Argument `dat` isn't a data table. See ?filter_space_loci.")
}
# Check for correct columns
if(sum(c(sampCol, locusCol, dpCol, aoCol) %in% colnames(dat))!=4){
stop("Not all specified columns (`sampCol`, `locusCol`, `dpCol`, `aoCol`) are in data.table dat. See ?filter_space_loci.")
}
# Check that the supporting reads is a positive value
if(suppReads<1){
stop('Argument `stepSize` must be >=1. See ?filter_space_loci.')
}
# --------------------------------------------+
# Code
# --------------------------------------------+
# Rename columns
dat <- dat %>%
copy %>%
setnames(., c(sampCol, locusCol, dpCol, aoCol), c('SAMPLE','LOCUS','DP','AO')) %>%
.[, RO:=DP-AO]
# Assign "zygosity"
dat[, ZYG:=if_else(DP==RO | DP==AO, 'Hom', 'Het')]
# Assign "keep" status based on zygosity and supporting read threshold
dat[ZYG=='Hom', KEEP:=TRUE]
dat[ZYG=='Het', KEEP:=if_else((RO<suppReads) & (AO<suppReads), FALSE, TRUE)]
# Out
return(dat[, c('SAMPLE','LOCUS','KEEP')])
}
# Make all documents
roxygenise(clean=TRUE)
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyverse')
for(L in libs){require(L, character.only=TRUE)}
# Make all documents
roxygenise(clean=TRUE)
library(genomalicious)
library(genomalicious)
library(genomalicious)
library(genomalicious)
#' Filter samples by the minimum supporting reads for alleles.
#'
#' This function can almost be seen like a minor allele frequency or count filter
#' at the level of a the sample (instead of the whole dataset). It will mark
#' a sample as having insufficient supporting reads for the allele with lower coverage
#' if they are below a certain threshold. This might be useful, for example, when
#' using pooled allele frequencies, or when genotypes individuals are sequenced at
#' low-to-moderate coverage.
#'
#' @param dat Data.table: Contains the information of samples, loci, the total depth
#' of coverage, and the read count of the alterante allele. The reference allele read count
#' is assumed to be 1 - alternate allele read count.
#' Must contain the columns:
#' \enumerate{
#'    \item The sample ID (see param \code{sampCol}).
#'    \item The locus ID (see param \code{locusCol}).
#'    \item The total read depth (see param \code{dpCol}).
#'    \item The alternate allele read counts (see param \code{aoCol}).
#' }
#'
#' @param sampCol Character: The column with the sample information.
#' Default = \code{'SAMPLE'}.
#'
#' @param locusCol Character: The column with the locus information.
#' Default = \code{'LOCUS'}.
#'
#' @param dpCol Character: The column with the total read depth information.
#' Default = \code{'DP'}.
#'
#' @param aoCol Character: The column with the alternate allele read count information.
#' Default = \code{'AO'}.
#'
#' @param suppReads Integer: The minimum number of supporting reads for the allele that
#' is least well covered by reads within a sample.
#'
#' @details Note, this sample will only evaluate sites for each there are reads
#' supporting both alleles. It will not evaluate sites that only have reads for the
#' reference alleles, or only have reads for the alternate allele.
#'
#' @returns Returns a data.table with the columns \code{$SAMPLE} and \code{$LOCUS},
#' the sample and locus information, and \code{KEEP}, a logical column with TRUE or FALSE
#' indicating whether a sample + locus observation should be kept based on uncertainty
#' in the supporting reads. Note, all samples + loci observations are returned, such that
#' they will match \code{dat}. This facilitates merging of the original data and results.
#'
#' @examples
#' library(genomalicious)
#' data(data_Genos)
#'
#' # Take a look at the read distribution for alternate alleles
#' hist(data_Genos$AO, xlab='Alt allele read counts', main='')
#'
#' # Let's find those sample + loci observations where there are not
#' # at least 5 reads supporting each allele
#' suppTest <- filter_supporting_reads(data_Genos, suppReads=5)
#'
#' head(suppTest)
#'
#' suppTest[KEEP==FALSE]
#'
#' # You could use this information to filter loci. For example, removing
#' # a locus if any sample does not meet the supporting read threshold for
#' # both alleles.
#' uniq_bad_loci <- unique(suppTest[KEEP==FALSE]$LOCUS)
#'
#' uniq_bad_loci
#'
#' data_Genos[!LOCUS %in% uniq_bad_loci]
#'
#' @export
filter_supporting_reads <- function(dat, sampCol='SAMPLE', locusCol='LOCUS', dpCol='DP', aoCol='AO', suppReads=3){
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
require(data.table); require(tidyverse)
# Test that the data table is the correct class.
if(!'data.table' %in% class(dat)){
stop("Argument `dat` isn't a data table. See ?filter_space_loci.")
}
# Check for correct columns
if(sum(c(sampCol, locusCol, dpCol, aoCol) %in% colnames(dat))!=4){
stop("Not all specified columns (`sampCol`, `locusCol`, `dpCol`, `aoCol`) are in data.table dat. See ?filter_space_loci.")
}
# Check that the supporting reads is a positive value
if(suppReads<1){
stop('Argument `stepSize` must be >=1. See ?filter_space_loci.')
}
# --------------------------------------------+
# Code
# --------------------------------------------+
# Rename columns
dat <- dat %>%
copy %>%
setnames(., c(sampCol, locusCol, dpCol, aoCol), c('SAMPLE','LOCUS','DP','AO')) %>%
.[, RO:=DP-AO]
# Assign "zygosity"
dat[, ZYG:=if_else(DP==RO | DP==AO, 'Hom', 'Het')]
# Assign "keep" status based on zygosity and supporting read threshold
dat[ZYG=='Hom', KEEP:=TRUE]
dat[ZYG=='Het', KEEP:=if_else(RO>=suppReads & AO>=suppReads, TRUE, FALSE)]
# Out
return(dat[, c('SAMPLE','LOCUS','KEEP')])
}
library(genomalicious)
data(data_Genos)
# Take a look at the read distribution for alternate alleles
suppTest <- filter_supporting_reads(data_Genos, suppReads=5)
head(suppTest)
suppTest[KEEP==FALSE]
left_join(data_Genos, suppTest[KEEP==FALSE])
left_join(data_Genos, suppTest)
left_join(data_Genos, suppTest) %>%
.[KEEP==FALSE]
library(genomalicious)
#' Filter loci based on their spacing
#'
#' A function to space loci based on a particular step size.
#' For each chromosome (contig), starting from the first locus, each
#' subsequent locus is assessed with respect to whether it is further
#' than the step size from the previous locus. If a locus is not >= the
#' step size, it will be skipped, and the next locus evaluated.
#' @param dat Data.table: Contains the information on the genomic context of each
#' locus, that is, their position and which chromosome/contig they reside on. You can
#' pass this function a genotype data.table (e.g., as produced from \code{vcf2DT()}),
#' because it will subset only the unique chromosome, position, and locus information.
#' Must contain the columns:
#' \enumerate{
#'    \item The chromosome/contig ID (see param \code{chromCol}).
#'    \item The positional information (see param \code{posCol}).
#'    \item The locus ID (see param \code{locusCol}).
#' }
#'
#' @param chromCol Character: The column name with the chromosome information.
#' Default = \code{'CHROM'}.
#'
#' @param posCol Character: The column name with the position information.
#' Default = \code{'POS'}.
#'
#' @param locusCol Character: The column name with the locus name information.
#' Default = \code{'LOCUS'}.
#'
#' @param stepSize Integer: the size of steps between loci.
#'
#' @returns Returns a vector of loci IDs to be kept.
#'
#' @export
filter_space_loci <- function(dat, chromCol='CHROM', posCol='POS', locusCol='LOCUS', stepSize){
# BEGIN ...........
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
require(data.table); require(tidyverse)
# Test that the data table is the correct class.
if(!'data.table' %in% class(dat)){
stop("Argument `dat` isn't a data table. See ?filter_space_loci.")
}
# Check for correct columns
if(sum(c(chromCol, posCol, locusCol) %in% colnames(dat))!=3){
stop("Not all specified columns (`chromCol`, `posCol`, `locusCol`) are in data.table dat. See ?filter_space_loci.")
}
# Check that the step size is a positive value
if(stepSize<1){
stop('Argument `stepSize` must be >=1. See ?filter_space_loci.')
}
# --------------------------------------------+
# Code
# --------------------------------------------+
# Rename columns
dat <- dat %>%
copy %>%
setnames(., c(chromCol, posCol, locusCol), c('CHROM','POS','LOCUS'))
# Get unique loci
D.uniq.loci <- dat[, c('CHROM','POS','LOCUS')] %>% unique()
# Iterate over chromosomes
D.keep.loci <- unique(D.uniq.loci$CHROM) %>%
lapply(., function(chrom){
# Subset the chormosome
D.chr.sub.loci <- D.uniq.loci[CHROM==chrom] %>%
setorder(., POS)
# Iterate over loci if more than 1 per contig
if(nrow(D.chr.sub.loci)>1){
# Default keep the first locus
D.chr.sub.loci[1, KEEP:=TRUE]
# Iterate through each subsequent locus, keep if >= stepSize from
# the previous locus.
for(i in 2:nrow(D.chr.sub.loci)){
pos.diff <- D.chr.sub.loci$POS[i] - D.chr.sub.loci$POS[i-1]
if(pos.diff >= stepSize){
D.chr.sub.loci$KEEP[i] <- TRUE
} else{
D.chr.sub.loci$KEEP[i] <- FALSE
}
}
# Output
D.chr.sub.loci
}
}) %>%
# Combine all chromosomes
do.call('rbind', .)
# Output
return(D.keep.loci[KEEP==TRUE]$LOCUS)
# ... END
}
#' Filter loci based on their spacing
#'
#' A function to space loci based on a particular step size.
#' For each chromosome (contig), starting from the first locus, each
#' subsequent locus is assessed with respect to whether it is further
#' than the step size from the previous locus. If a locus is not >= the
#' step size, it will be skipped, and the next locus evaluated.
#' @param dat Data.table: Contains the information on the genomic context of each
#' locus, that is, their position and which chromosome/contig they reside on. You can
#' pass this function a genotype data.table (e.g., as produced from \code{vcf2DT()}),
#' because it will subset only the unique chromosome, position, and locus information.
#' Must contain the columns:
#' \enumerate{
#'    \item The chromosome/contig ID (see param \code{chromCol}).
#'    \item The positional information (see param \code{posCol}).
#'    \item The locus ID (see param \code{locusCol}).
#' }
#'
#' @param chromCol Character: The column name with the chromosome information.
#' Default = \code{'CHROM'}.
#'
#' @param posCol Character: The column name with the position information.
#' Default = \code{'POS'}.
#'
#' @param locusCol Character: The column name with the locus name information.
#' Default = \code{'LOCUS'}.
#'
#' @param stepSize Integer: the size of steps between loci.
#'
#' @returns Returns a vector of loci IDs to be kept.
#'
#' @export
filter_space_loci <- function(dat, chromCol='CHROM', posCol='POS', locusCol='LOCUS', stepSize){
# BEGIN ...........
# --------------------------------------------+
# Libraries and assertions
# --------------------------------------------+
require(data.table); require(tidyverse)
# Test that the data table is the correct class.
if(!'data.table' %in% class(dat)){
stop("Argument `dat` isn't a data table. See ?filter_space_loci.")
}
# Check for correct columns
if(sum(c(chromCol, posCol, locusCol) %in% colnames(dat))!=3){
stop("Not all specified columns (`chromCol`, `posCol`, `locusCol`) are in data.table dat. See ?filter_space_loci.")
}
# Check that the step size is a positive value
if(stepSize<1){
stop('Argument `stepSize` must be >=1. See ?filter_space_loci.')
}
# --------------------------------------------+
# Code
# --------------------------------------------+
# Rename columns
dat <- dat %>%
copy %>%
setnames(., c(chromCol, posCol, locusCol), c('CHROM','POS','LOCUS'))
# Get unique loci
D.uniq.loci <- dat[, c('CHROM','POS','LOCUS')] %>% unique()
# Iterate over chromosomes
D.keep.loci <- unique(D.uniq.loci$CHROM) %>%
lapply(., function(chrom){
# Subset the chormosome
D.chr.sub.loci <- D.uniq.loci[CHROM==chrom] %>%
setorder(., POS)
# Iterate over loci if more than 1 per contig
if(nrow(D.chr.sub.loci)>1){
# Default keep the first locus
D.chr.sub.loci[1, KEEP:=TRUE]
# Iterate through each subsequent locus, keep if >= stepSize from
# the previous locus.
for(i in 2:nrow(D.chr.sub.loci)){
pos.diff <- D.chr.sub.loci$POS[i] - D.chr.sub.loci$POS[i-1]
if(pos.diff >= stepSize){
D.chr.sub.loci$KEEP[i] <- TRUE
} else{
D.chr.sub.loci$KEEP[i] <- FALSE
}
}
# Output
D.chr.sub.loci
}
}) %>%
# Combine all chromosomes
do.call('rbind', .)
# Output
return(D.keep.loci[KEEP==TRUE]$LOCUS)
# ... END
}
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyverse')
for(L in libs){require(L, character.only=TRUE)}
# Make just those documents that have changed
roxygenise()
library(genomalicious)
