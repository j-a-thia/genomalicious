if(!class(sampPloidy) %in% c('numeric','integer')){
stop('Argument `sampPloidy` value must be an integer/numeric class. See ?DT2RADdata.')
}
# Check that sample ploidies are specified correctly as a named vector
if(length(sampPloidy)>1){
# Names present
if(is.null(names(sampPloidy))){
stop('Argument `sampPloidy` is specified as a vector, but sample names were not detected. See ?DT2RADdata.')
}
# All names match samples in dat
uniq_samps <- dat[[sampCol]] %>% unique
n_samps <- length(uniq_samps)
if(sum(uniq_samps %in% names(sampPloidy)) != n_samps){
stop('The samples in argument `dat` must all appear in the names in the argument `sampPloidy` if `sampPloidy` is specified as a vector. See ?DT2RADdata')
}
}
# --------------------------------------------+
# Code
# --------------------------------------------+
# Get the unique loci
uniqLociDt <- copy(dat[, c('LOCUS', 'CHROM', 'POS', 'REF', 'ALT')]) %>% unique()
setorder(uniqLociDt, 'CHROM', 'POS')
# Create allele names and number
uniqLociDt[, VAR.REF:=paste(LOCUS, REF, sep='_')]
uniqLociDt[, VAR.ALT:=paste(LOCUS, ALT, sep='_')]
uniqLociDt[, VAR.NUM:=1:nrow(uniqLociDt)]
# Get the unique samples
uniqSamps <- sort(unique(dat$SAMPLE))
# Create a matrix of allele read counts for each sample.
# Each locus is represented by two columns: one for the Ref
# allele, and another for the Alt allele counts.
# Therefore, for n samples and m loci, the dimensions of
# the matrix are n x 2m.
# Create unique alleles names for each locus
dat[, VAR.REF:=paste(LOCUS, REF, sep='_')]
dat[, VAR.ALT:=paste(LOCUS, ALT, sep='_')]
# Get the Ref and Alt observed read counts per allele.
# Loci will be in the same order in each of these wide data tables.
ro_wDT <- dcast(dat, SAMPLE ~ VAR.REF, value.var = 'RO')
ao_wDT <- dcast(dat, SAMPLE ~ VAR.ALT, value.var = 'AO')
# Convert to matrices
roMat <- ro_wDT %>%
column_to_rownames(var='SAMPLE') %>%
as.matrix()
aoMat <- ao_wDT %>%
column_to_rownames(var='SAMPLE') %>%
as.matrix()
# Replace NA with 0
roMat[is.na(roMat)] <- 0
aoMat[is.na(aoMat)] <- 0
# Make sure rownames in roMat and aoMat match
aoMat <- aoMat[match(rownames(roMat), rownames(aoMat)),]
# Make sure alleles are ordered by loci
roMat <- roMat[, uniqLociDt$VAR.REF]
aoMat <- aoMat[, uniqLociDt$VAR.ALT]
# Combine into single matrix and transform to integer class
depthMat <- apply(cbind(roMat, aoMat), 2, as.integer)
rownames(depthMat) <- rownames(roMat)
# Genetic info vectors
chrVec <- uniqLociDt$CHROM
posVec <- uniqLociDt$POS
locVec <- uniqLociDt$LOCUS
nucVec <- c(uniqLociDt$REF, uniqLociDt$ALT)
# Build RADdata object
rad_data <- RADdata(
alleleDepth=depthMat,
alleles2loc=c(1:ncol(roMat), 1:ncol(aoMat)),
locTable=data.frame(Chr=chrVec, Pos=posVec, row.names=locVec),
possiblePloidies=possPloidy,
contamRate=contamRate,
alleleNucleotides=nucVec,
taxaPloidy=sampPloidy
)
return(rad_data)
# ........ END
}
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyverse')
for(L in libs){require(L, character.only=TRUE)}
# Make just those documents that have changed
roxygenise()
library(genomalicious)
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyverse')
for(L in libs){require(L, character.only=TRUE)}
# Make just those documents that have changed
roxygenise()
library(genomalicious)
RD1 <- DT2RADdata(data_Genos, sampPloidy=2)
library(genomalicious)
data(data_Genos)
RD1 <- DT2RADdata(data_Genos, sampPloidy=2)
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyverse')
for(L in libs){require(L, character.only=TRUE)}
# Make just those documents that have changed
roxygenise()
library(genomalicious)
# Make all documents
roxygenise(clean=TRUE)
library(genomalicious)
library(genomalicious)
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyverse')
for(L in libs){require(L, character.only=TRUE)}
featureRef <- fread('00_Misc_data/mito_annot_features.csv')
featureRefs <- fread(paste(genomaliciousExtData, 'data_Bcocosensis_mito_features.csv', sep='/'))
genomaliciousExtData <- paste0(find.package('genomalicious'), '/extdata')
featureRefs <- fread(paste(genomaliciousExtData, 'data_Bcocosensis_mito_features.csv', sep='/'))
featureRefs <- fread(paste(genomaliciousExtData, 'data_Bcocosensis_mito_features.csv'), sep='/'))
paste0(genomaliciousExtData, 'data_Bcocosensis_mito_features.csv')
featureRefs <- fread(paste0(genomaliciousExtData, 'data_Bcocosensis_mito_features.csv')))
featureRefs <- fread(paste0(genomaliciousExtData, 'data_Bcocosensis_mito_features.csv'))
genomaliciousExtData <- paste0(find.package('genomalicious'), '/extdata')
paste0(genomaliciousExtData, 'data_Bcocosensis_mito_features.csv')
featureRefs <- fread(paste0(genomaliciousExtData, '/data_Bcocosensis_mito_features.csv'))
featureRefs <- fread(paste0(genomaliciousExtData, '/data_Bcocosensis_mito_features.csv'))
genomaliciousExtData <- paste0(find.package('genomalicious'), '/extdata')
genomaliciousExtData
genomaliciousExtData <- paste0(find.package('genomalicious'), '/extdata')
genomaliciousExtData
paste0(genomaliciousExtData, '/data_Bcocosensis_mito_features.csv')
"C:/Users/thiaj/AppData/Local/R/win-library/4.3/genomalicious/inst/extdata/data_Bcocosensis_mito_features.csv" -> featureRefs
featureRefs
bedFilePath <- fread(paste0(genomaliciousExtData, '/data_Bcocosensis_mito_annots.bed'))
bedFilePath <- paste0(genomaliciousExtData, '/data_Bcocosensis_mito_annots.bed')
bcocoFtRefs
bcocoFtRefs <- fread("C:/Users/thiaj/AppData/Local/R/win-library/4.3/genomalicious/inst/extdata/data_Bcocosensis_mito_features.csv")
# Make just those documents that have changed
roxygenise()
# Make just those documents that have changed
roxygenise()
library(genomalicious)
library(genomalicious)
genomaliciousExtData <- paste0(find.package('genomalicious'), '/extdata')
# genes from the Bathygobius cocosensis mitogenome.
bcocoFtRefs <- fread(paste0(genomaliciousExtData, '/data_Bcocosensis_mito_features.csv'))
bcocoBedPath <- paste0(genomaliciousExtData, '/data_Bcocosensis_mito_annots.bed')
bcocoFtRefs
bcocoBedPath
readLines(bcocoBedPath)
# Make just those documents that have changed
roxygenise()
library(genomalicious)
# Run
bed2featuretab(bcocoBedPath, bcocoFtRefs, 'Bcoco_feature_table.txt')
# Make all documents
roxygenise(clean=TRUE)
library(genomalicious)
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyverse')
for(L in libs){require(L, character.only=TRUE)}
library(Biostrings)
DNAStringSet('AA')
# Make just those documents that have changed
roxygenise()
library(genomalicious)
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyverse')
for(L in libs){require(L, character.only=TRUE)}
# Make just those documents that have changed
roxygenise()
library(genomalicious)
?assembly_correct_gaps
# Make just those documents that have changed
roxygenise()
?assembly_correct_gaps
library(genomalicious)
?assembly_correct_gaps
# Make just those documents that have changed
roxygenise()
library(genomalicious)
cat(i, '/', num_seqs)
library(genomalicious)
library(genomalicious)
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyverse')
for(L in libs){require(L, character.only=TRUE)}
# Make just those documents that have changed
roxygenise()
# Make just those documents that have changed
roxygenise()
library(genomalicious)
cat(i, '/', num_seqs, '\n')
#' Correct uneven gaps in an assembled genome
#'
#' Uneven gap sizes can form during genome assembly as different
#' assembling, polishing, and gap closing tools pile on top of each
#' other. This makes submission of a genome assembly problematic,
#' because varying gap sizes are ambiguous, and ideally we want unknown
#' gaps to have a standardised size. \cr\cr
#' This function takes a genome assembly and corrects gap sizes given
#' a user-define threshold. It is assumed that any gap larger than the
#' threshold is an unknown gap.
#'
#' @param genomeSS DNAStringSet: the genome assembly as a 'DNAStringSet'
#' object from the \code{Biostrings} package.
#'
#' @param threshold Integer: the minimum string of 'N's to consider a gap.
#'
#' @param correct Integer: the standardised number of 'N's for gaps of unknown size.
#' @returns Returns the genome assembly back as a DNAStringSet object with all
#' gaps meeting the threshold size standardized to the corrected size.
#' Sequences with corrected gaps are labelled with '_correct_gaps'.
#'
#' @export
assembly_correct_gaps <- function(genomeSS, threshold, correct){
require(Biostrings); require(data.table); require(doParallel); require(tidyverse)
# Quick checks
if(!'DNAStringSet' %in% class(genomeSS)){
stop('Argument `genomeSS` must be a "DNAStringSet" class. See ?assembly_correct_gaps.')
}
if(class(threshold)!='integer' | threshold<1){
stop('Argument `treshold` must be an "integer" class with a values >0. See ?assembly_correct_gaps.')
}
if(class(correct)!='integer' | correct<1){
stop('Argument `correct` must be an "integer" class with a values >0. See ?assembly_correct_gaps.')
}
# Iterate through each ith genomic sequence
resultsList <- list()
num_seqs <- length(genomeSS)
for(i in 1:num_seqs){
cat(i, '/', num_seqs, '\n')
require(Biostrings); require(data.table); require(tidyverse)
# Convert the sequence into a long-format data table
seq_i_tab <- genomeSS[i] %>%
as.matrix() %>%
t() %>%
as.data.table() %>%
setnames(., new='DNA')
# Add in an index and test whether the bases are Ns
seq_i_tab[, INDEX:=1:.N]
seq_i_tab[, IS.N:=DNA=='N']
# Subset and sort indexes with Ns. Gap IDs are currently unknown.
n_i_tab <- seq_i_tab[IS.N==TRUE] %>%
setorder(., INDEX) %>%
.[, GAP:=0L]
# Counter of unique gap IDs.
uniq_gap_count <- 1L
# Iterate through each jth index where there is an N.
# Test whether the jth index is exactly j+1 the previous index.
# If yes, then they are consecutive and part of the same gap.
# If no, then they are different gaps, and the counter goes up
for(j in 1:nrow(n_i_tab)){
if(j == 1){
n_i_tab$GAP[j] <- uniq_gap_count
} else if(j > 1){
index_j <- n_i_tab$INDEX[j]
index_j_m1 <- n_i_tab$INDEX[j-1]
index_consec <- index_j - 1 == (index_j_m1)
if(index_consec==TRUE){
n_i_tab$GAP[j] <- uniq_gap_count
} else if(index_consec==FALSE){
uniq_gap_count <- uniq_gap_count + 1
n_i_tab$GAP[j] <- uniq_gap_count
}
}
}
# Summarise the size of unique gaps
size_i_tab <- n_i_tab[, .(SIZE=length(INDEX)), by=GAP] %>%
.[, KEEP:=SIZE>=threshold]
keep_gaps_i <- size_i_tab[KEEP==TRUE]$GAP
# Return original sequence, or sequence with standardised gaps
if(nrow(size_i_tab)==0){
result_i <- genomeSS[i]
} else {
# The N string to replace corrected gaps
n_string <- paste(rep('N',correct), collapse='')
# Starting site for each gap
keep_i_tab <- n_i_tab[GAP %in% keep_gaps_i] %>%
copy %>%
.[, START:=INDEX==min(INDEX), by=GAP]
# Add in the info for the gaps to keep
seq_i_tab <- left_join(seq_i_tab, keep_i_tab, by=c('INDEX','IS.N'))
# Replace the string of the start site for each gap
seq_i_tab[!is.na(GAP) & START==TRUE, DNA:=n_string]
# Keep only sites that are 'A', 'T', 'G', 'C', or the first
# site for each gap. Make sure the sites are in order then
# paste them back together and convert into a string set.
new_seq_i <- seq_i_tab[is.na(GAP) | (!is.na(GAP) & START==TRUE)] %>%
setorder(., INDEX) %>%
.[['DNA']] %>%
paste(., collapse='') %>%
DNAStringSet()
# Add in the sequence name, but note that it is corrected.
names(new_seq_i) <- paste0(names(genomeSS[i]), '_correct_gaps')
# Add to results
result_i <- new_seq_i
}
# Cleanup and return results
gc()
resultsList[[i]] <- result_i
# End ith iteration
}
}
# Make just those documents that have changed
roxygenise()
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyverse')
for(L in libs){require(L, character.only=TRUE)}
# Make just those documents that have changed
roxygenise()
library(genomalicious)
library(genomalicious)
do.call('c', resultsList)
library(genomalicious)
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyverse')
for(L in libs){require(L, character.only=TRUE)}
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyverse')
for(L in libs){require(L, character.only=TRUE)}
library(genomalicious)
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyverse')
for(L in libs){require(L, character.only=TRUE)}
# Make just those documents that have changed
roxygenise()
library(genomalicious)
#' DNA to a translated codon data.table
#'
#' Convert a DNA coding sequence into a data.table of codons and amino acids.
#'
#' @param dnaSeq Character: For a coding sequence (e.g., cDNA transcript), a single
#' character vector. For a group of exons, a list of character vectors.
#' See argument \code{type} and Details.
#'
#' @param type Character: one of \code{'cds'} (coding sequence) or \code{'exons'}
#' (exon regions). See Details.
#'
#' @param compressTab Logical: Should the table be compressed? Default is TRUE,
#' in which case, each row is a unique codon. If FALSE, then each codon is represented
#' by 3 rows, one for each nucleotide comprising the codon.
#'
#' @param geneticCode Integer: A value relating to the \code{numcode} argument in
#' \code{seqinr::translate}.
#'
#' @details The argument \code{type} dictates what to pass to the argument
#' \code{dnaSeq}. If you want to translate a coding sequence (cDNA transcript),
#' then \code{type=='cds'} and \code{dnaSeq} must recieve a single character,
#' the DNA sequence.
#'
#' If you want to translate a series of exons, then \code{type='exon'} and
#' \code{dnaSeq} must receive a list, where each indexed item in the list is
#' a character vector, the DNA exon sequence. Note, it is assumed that the
#' exon sequences are ordered correctly, from first to last.
#'
#' For both cases, the function assumes that the sequence is in the correct
#' reading frame.
#'
#' @return
#' Returns a data.table with the following columns when \code{compressTab==TRUE}:
#'
#' \enumerate{
#'    \item \code{$CODON} = The codon number, 1:N.
#'    \item \code{$NUC} = The nucleotides positions comprising the codon, from
#'    1 to the gene's length.
#'    \item \code{$DNA} = The DNA bases.
#'    \item \code{$AMINO} = The amino acid residue.
#'    \item \code{$EXON} = The exon number, but only when \code{type=='exon'}.
#' }
#'
#' Otherwise, if \code{compressTab==FALSE}:
#'
#' \enumerate{
#'    \item \code{$CODON} = The codon number, 1:N.
#'    \item \code{$NUC.GENE} = The nucleotides position within the gene, from
#'    from 1 to the gene's length.
#'    \item \code{$NUC.CODON} = The nucleotides positions within the codon, from
#'    1 to 3.
#'    \item \code{$DNA} = The DNA bases.
#'    \item \code{$AMINO} = The amino acid residue.
#'    \item \code{$EXON} = The exon number, but only when \code{type=='exon'}.
#' }
#'
#' @examples
#' X <- 'ATGCGTACTTCA'
#'
#' dna2codonDT(X, compressTab=TRUE)
#'
#' dna2codonDT(X, compressTab=FALSE)
#'
#' @export
dna2codonDT <- function(dnaSeq, type, compressTab=FALSE, geneticCode=1){
require(data.table)
require(seqinr)
require(tidyverse)
# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
###   ASSERTIONS   ####
# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
if(!type %in% c('cds','exon')){
stop('Argument `type` must be one of "cds" or "exon". See dna2codonDT.')
}
if(type=='cds' & class(dnaSeq)!='character'){
stop('Argument `dnaSeq` must be a single vector of character class when
argument `type=="cds"`. See ?dna2codonDT.')
}
if(type=='exon' & class(dnaSeq)!='list'){
stop('Argument `dnaSeq` must be a list of character class vectors when
argument `type=="exon"`. See ?dna2codonDT.')
}
if(class(compressTab)!='logical'){
stop('Argument `type` must be a logical class. See ?dna2codonDT.')
}
# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
###   INTERNAL FUNCTION   ###
# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
FUN_dna_2_cod <- function(seq_as_char, compressTab){
# Split the sequence into codons
codonList <- seqinr::splitseq(
seq = seq_as_char  %>% as.character %>% s2c
)
# Iterate over ith the codons
codonTab <- lapply(1:length(codonList), function(i){
# Subset codon
cod <- codonList[i]
# Get the relative nucleotide positions within the codon
n <- length(codonList[1:i])*3
# Get the amino acid
amino <- seqinr::translate(cod %>% s2c, numcode=geneticCode)
# Make the table for this codon
if(compressTab==TRUE){
# Compressed table format
tab <- data.table(
CODON=i,
NUC=paste(n-2, n-1, n, sep='|'),
DNA=cod,
AMINO=amino
)
} else if(compressTab==FALSE){
# Uncompressed table format
tab <- data.table(
CODON=i,
NUC.GENE=c(n-2, n-1, n),
NUC.CODON=1:3,
DNA=strsplit(cod, '')[[1]],
AMINO=amino
)
}
}) %>%
do.call('rbind',.)
return(codonTab)
}
# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
###   EXECUTE   ###
# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
# If only providing coding sequence as single character string
if(type=='cds'){
result <- FUN_dna_2_cod(seq_as_char=dnaSeq, compressTab=compressTab)
}
# If providing exons as list of character strings
if(type=='exon'){
# Number of exons
n <- length(dnaSeq)
# Iterate over exons to create an index table for codons + nucleotides
nucGeneIndex <- lapply(1:n, function(i){
data.table(EXON=i, DNA=str_split(dnaSeq[[i]], '')[[1]])
}) %>%
do.call('rbind', .) %>%
.[, NUC.GENE:=1:.N]
# Get the codon table for the combined exons
result <- paste(nucGeneIndex$DNA, collapse='') %>%
FUN_dna_2_cod(seq_as_char=., compressTab=compressTab)
# Add in the codons + nucleotides indexes for uncompressed and compressed
# trasnlated codon data tables
if(compressTab==FALSE){
result <- left_join(result, nucGeneIndex)
}
if(compressTab==TRUE){
# Align in the compressed nucleotide indexes against exons and codons
nucGeneIndex <- result %>%
.[, .(NUC.GENE=as.integer(unlist(str_split(NUC, '\\|')))), by=c('CODON','NUC')] %>%
left_join(., nucGeneIndex, by='NUC.GENE')
exonByCodon <- nucGeneIndex %>%
.[, .(EXON=paste(sort(unique(EXON)),collapse='|')), by=CODON]
# Combine
result <- left_join(result, exonByCodon)
}
}
# Output
return(result)
}
library(genomalicious)
library(genomalicious)
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyverse')
for(L in libs){require(L, character.only=TRUE)}
# Make just those documents that have changed
roxygenise()
library(genomalicious)
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyverse')
for(L in libs){require(L, character.only=TRUE)}
# Make just those documents that have changed
roxygenise()
library(genomalicious)
# Make just those documents that have changed
roxygenise()
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyverse')
for(L in libs){require(L, character.only=TRUE)}
# Make just those documents that have changed
roxygenise()
library(genomalicious)
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyverse')
for(L in libs){require(L, character.only=TRUE)}
# Make just those documents that have changed
roxygenise()
# Make just those documents that have changed
roxygenise()
library(genomalicious)
