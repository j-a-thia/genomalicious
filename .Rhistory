#' \enumerate{
#'    \item \code{$SIM}, the simulation number for pairs of simulated individuals,
#'    or 'NA' for the pairs of observed individuals.
#'    \item \code{$SAMPLE1}, the sample ID for the first individual.
#'    \item \code{$SAMPLE2}, the sample ID for the second individual.
#'    \item \code{$FAMILY}, the familial relationship for simulated individuals.
#'    \item \code{$Y}, the value in the cell contents from the input matrix.
#' }
#'
#' @examples
#' library(genomalicious)
#' data(data_Genos)
#'
#' # Subset Pop1 genotypes
#' genosPop1 <- data_Genos[POP=='Pop1', c('SAMPLE', 'LOCUS', 'GT')]
#'
#' # Get the allele frequencies for Pop1
#' freqsPop1 <- genosPop1[, .(FREQ=sum(GT)/(length(GT)*2)), by=LOCUS]
#'
#' # Simulate 100 families
#' simFamily <- family_sim_data(
#'    freqData=freqsPop1,
#'    locusCol='LOCUS',
#'    freqCol='FREQ',
#'    numSims=100
#' )
#'
#' ### THE SIMULATED GENETIC RELATIONSHIPS MATRIX
#' library(AGHmatrix)
#'
#' # Convert simulated families into a genotype matrix
#' simGenosMat <- DT2Mat_genos(simFamily)
#'
#' # Calculate the GRM
#' simGRM <- Gmatrix(simGenosMat, method='Yang', ploidy=2)
#'
#' # Get the pairwise samples in long-format with familial annotations
#' family_sim_annotate(simMat = simGRM)
#'
#' @export
family_sim_annotate <- function(simMat){
if(!'matrix' %in% class(simMat)){
stop('Argument `simMat` must be of class "matrix". See ?family_sim_annotate.')
}
require(data.table); require(tidyverse)
annotDT <- simMat %>%
pairwiseMat2DT(., X1='SAMPLE1', X2='SAMPLE2', Y='Y') %>%
.[SAMPLE1!=SAMPLE2]
annotDT[, SIM1:=sub('_.*', '', SAMPLE1)]
annotDT[, SIM2:=sub('_.*', '', SAMPLE2)]
annotDT[SIM1!=SIM2, FAMILY:='Unrelated']
annotDT[
SIM1 == SIM2 &
grepl('_unrel_',SAMPLE1)==TRUE &
grepl('_unrel_',SAMPLE2)==TRUE,
FAMILY:='Unrelated'
]
annotDT[
SIM1 == SIM2 &
grepl('_sib_',SAMPLE1)==TRUE &
grepl('_sib_',SAMPLE2)==TRUE,
FAMILY:='Siblings'
]
annotDT[
SIM1 == SIM2 &
grepl('_halfsib_',SAMPLE1)==TRUE &
grepl('_halfsib_',SAMPLE2)==TRUE,
FAMILY:='Half-siblings'
]
annotDT[
SIM1 == SIM2 &
grepl('_cous_',SAMPLE1)==TRUE &
grepl('_cous_',SAMPLE2)==TRUE,
FAMILY:='Cousins'
]
annotDT[
SIM1 == SIM2 &
grepl('_halfcous_',SAMPLE1)==TRUE &
grepl('_halfcous_',SAMPLE2)==TRUE,
FAMILY:='Half-cousins'
]
annotDT[SIM1 == SIM2 & is.na(FAMILY), FAMILY:='Unrelated']
annotDT <- annotDT[, SIM:=paste0(SIM1, '|', SIM2)] %>%
.[, !c('SIM1','SIM2')]
return(annotDT[, c('SIM','SAMPLE1','SAMPLE2','FAMILY','Y')])
}
family_sim_annotate(simMat = simGRM)
#' Annotate pairwise matrix of simulated family members
#'
#' Takes a pairwise matrix of individuals generated from \code{family_sim_data}
#' and annotates familial relationships across all pairs of individuals. Note,
#' the pairwise matrix could contain any data, but it is assumed the individuals
#' follow the naming conventions from \code{family_sim_data}.
#'
#' @param simFam Matrix or Character: Either a pairwise matrix or a character vector of
#' individual IDs. If a pairwise matrix, the matrix must be symmetrical:
#' diagonal compares indiviudals to themselves, and off-diagonal is comparisons
#' between individuals; must set \code{type=="matrix"}. If a character vector
#' of sample IDs, must set \code{type=="character"}
#'
#' @param type Character: Either "matrix" or "id_vec".
#'
#' @returns Returns a long-format data.table with the columns:
#' \enumerate{
#'    \item \code{$SIM}, the simulation number for pairs of simulated individuals,
#'    or 'NA' for the pairs of observed individuals.
#'    \item \code{$SAMPLE1}, the sample ID for the first individual.
#'    \item \code{$SAMPLE2}, the sample ID for the second individual.
#'    \item \code{$FAMILY}, the familial relationship for simulated individuals.
#'    \item \code{$Y}, the value in the cell contents from the input matrix.
#' }
#'
#' @examples
#' library(genomalicious)
#' data(data_Genos)
#'
#' # Subset Pop1 genotypes
#' genosPop1 <- data_Genos[POP=='Pop1', c('SAMPLE', 'LOCUS', 'GT')]
#'
#' # Get the allele frequencies for Pop1
#' freqsPop1 <- genosPop1[, .(FREQ=sum(GT)/(length(GT)*2)), by=LOCUS]
#'
#' # Simulate 100 families
#' simFamily <- family_sim_data(
#'    freqData=freqsPop1,
#'    locusCol='LOCUS',
#'    freqCol='FREQ',
#'    numSims=100
#' )
#'
#' ### THE SIMULATED GENETIC RELATIONSHIPS MATRIX
#' library(AGHmatrix)
#'
#' # Convert simulated families into a genotype matrix
#' simGenosMat <- DT2Mat_genos(simFamily)
#'
#' # Calculate the GRM
#' simGRM <- Gmatrix(simGenosMat, method='Yang', ploidy=2)
#'
#' ### THE FAMILAL ANNOTATIONS
#' # From a pairwise matrix (the GRM)
#' family_sim_annotate(simFam = simGRM, type = 'matrix')
#'
#' # From a vector of unique individual IDs
#' family_sim_annotate(simFam = rownames(simGRM), type = 'id_vec')
#'
#' @export
family_sim_annotate <- function(simFam, type){
if(type=='matrix'){
if(!'matrix' %in% class(simFam)){
stop('Argument `simFam` must be of class "matrix" if argument `type` == "matrix". See ?family_sim_annotate.')
}
}
if(type=='id_vec'){
if(!'character' %in% class(simFam)){
stop('Argument `simFam` must be of class "character" if argument `type` == "id_vec". See ?family_sim_annotate.')
}
}
require(data.table); require(tidyverse)
# Sort the individual sample IDs based on input type
if(type=='matrix'){
annotDT <- simFam %>%
as.matrix() %>%
pairwiseMat2DT(., X1='SAMPLE1', X2='SAMPLE2', Y='Y') %>%
.[SAMPLE1!=SAMPLE2]
} else if(type=='id_vec'){
annotDT <- combn(sort(unique(simFam)), 2) %>%
as.data.table %>%
setnames(., new=c('SAMPLE1', 'SAMPLE2'))
}
# Simulation ID
annotDT[, SIM1:=sub('_.*', '', SAMPLE1)]
annotDT[, SIM2:=sub('_.*', '', SAMPLE2)]
# All individuals from different simulations are unrelated
annotDT[SIM1!=SIM2, FAMILY:='Unrelated']
# The simulated unrelated pair within simulations
annotDT[
SIM1 == SIM2 &
grepl('_unrel_',SAMPLE1)==TRUE &
grepl('_unrel_',SAMPLE2)==TRUE,
FAMILY:='Unrelated'
]
# The simulated sibling pair within simulations
annotDT[
SIM1 == SIM2 &
grepl('_sib_',SAMPLE1)==TRUE &
grepl('_sib_',SAMPLE2)==TRUE,
FAMILY:='Siblings'
]
# The simulated half-sibling pair within simulations
annotDT[
SIM1 == SIM2 &
grepl('_halfsib_',SAMPLE1)==TRUE &
grepl('_halfsib_',SAMPLE2)==TRUE,
FAMILY:='Half-siblings'
]
# The simulated cousins pair within simulations
annotDT[
SIM1 == SIM2 &
grepl('_cous_',SAMPLE1)==TRUE &
grepl('_cous_',SAMPLE2)==TRUE,
FAMILY:='Cousins'
]
# The simulated half-cousins pair within simulations
annotDT[
SIM1 == SIM2 &
grepl('_halfcous_',SAMPLE1)==TRUE &
grepl('_halfcous_',SAMPLE2)==TRUE,
FAMILY:='Half-cousins'
]
# All other pairs within simulations are unrelated
annotDT[SIM1 == SIM2 & is.na(FAMILY), FAMILY:='Unrelated']
# Add in a simulation column
annotDT <- annotDT[, SIM:=paste0(SIM1, '|', SIM2)] %>%
.[, !c('SIM1','SIM2')]
# Output
if(type=='matrix'){
return(annotDT[, c('SIM','SAMPLE1','SAMPLE2','FAMILY','Y')])
} else if(type=='id_vec'){
return(annotDT)
}
}
simFamily
library(AGHmatrix)
simGenosMat <- DT2Mat_genos(simFamily)
simGenosMat
simGRM <- Gmatrix(simGenosMat, method='Yang', ploidy=2)
family_sim_annotate(simFam = simGRM, type = 'matrix')
family_sim_annotate(simFam = rownames(simGRM), type = 'id_vec')
simFam = rownames(simGRM)
type = 'id_vec'
if(type=='matrix'){
if(!'matrix' %in% class(simFam)){
stop('Argument `simFam` must be of class "matrix" if argument `type` == "matrix". See ?family_sim_annotate.')
}
}
if(type=='id_vec'){
if(!'character' %in% class(simFam)){
stop('Argument `simFam` must be of class "character" if argument `type` == "id_vec". See ?family_sim_annotate.')
}
}
require(data.table); require(tidyverse)
# Sort the individual sample IDs based on input type
if(type=='matrix'){
annotDT <- simFam %>%
as.matrix() %>%
pairwiseMat2DT(., X1='SAMPLE1', X2='SAMPLE2', Y='Y') %>%
.[SAMPLE1!=SAMPLE2]
} else if(type=='id_vec'){
annotDT <- combn(sort(unique(simFam)), 2) %>%
as.data.table %>%
setnames(., new=c('SAMPLE1', 'SAMPLE2'))
}
combn(sort(unique(simFam)), 2)
annotDT <- combn(sort(unique(simFam)), 2) %>%
t() %>%
as.data.table %>%
setnames(., new=c('SAMPLE1', 'SAMPLE2'))
annotDT
# Simulation ID
annotDT[, SIM1:=sub('_.*', '', SAMPLE1)]
annotDT[, SIM2:=sub('_.*', '', SAMPLE2)]
# All individuals from different simulations are unrelated
annotDT[SIM1!=SIM2, FAMILY:='Unrelated']
# The simulated unrelated pair within simulations
annotDT[
SIM1 == SIM2 &
grepl('_unrel_',SAMPLE1)==TRUE &
grepl('_unrel_',SAMPLE2)==TRUE,
FAMILY:='Unrelated'
]
# The simulated sibling pair within simulations
annotDT[
SIM1 == SIM2 &
grepl('_sib_',SAMPLE1)==TRUE &
grepl('_sib_',SAMPLE2)==TRUE,
FAMILY:='Siblings'
]
# The simulated half-sibling pair within simulations
annotDT[
SIM1 == SIM2 &
grepl('_halfsib_',SAMPLE1)==TRUE &
grepl('_halfsib_',SAMPLE2)==TRUE,
FAMILY:='Half-siblings'
]
# The simulated cousins pair within simulations
annotDT[
SIM1 == SIM2 &
grepl('_cous_',SAMPLE1)==TRUE &
grepl('_cous_',SAMPLE2)==TRUE,
FAMILY:='Cousins'
]
# The simulated half-cousins pair within simulations
annotDT[
SIM1 == SIM2 &
grepl('_halfcous_',SAMPLE1)==TRUE &
grepl('_halfcous_',SAMPLE2)==TRUE,
FAMILY:='Half-cousins'
]
# All other pairs within simulations are unrelated
annotDT[SIM1 == SIM2 & is.na(FAMILY), FAMILY:='Unrelated']
# Add in a simulation column
annotDT <- annotDT[, SIM:=paste0(SIM1, '|', SIM2)] %>%
.[, !c('SIM1','SIM2')]
annotDT
#' Annotate pairwise matrix of simulated family members
#'
#' Takes a pairwise matrix of individuals generated from \code{family_sim_data}
#' and annotates familial relationships across all pairs of individuals. Note,
#' the pairwise matrix could contain any data, but it is assumed the individuals
#' follow the naming conventions from \code{family_sim_data}.
#'
#' @param simFam Matrix or Character: Either a pairwise matrix or a character vector of
#' individual IDs. If a pairwise matrix, the matrix must be symmetrical:
#' diagonal compares indiviudals to themselves, and off-diagonal is comparisons
#' between individuals; must set \code{type=="matrix"}. If a character vector
#' of sample IDs, must set \code{type=="character"}
#'
#' @param type Character: Either "matrix" or "id_vec".
#'
#' @returns Returns a long-format data.table with the columns:
#' \enumerate{
#'    \item \code{$SIM}, the simulation number for pairs of simulated individuals,
#'    or 'NA' for the pairs of observed individuals.
#'    \item \code{$SAMPLE1}, the sample ID for the first individual.
#'    \item \code{$SAMPLE2}, the sample ID for the second individual.
#'    \item \code{$FAMILY}, the familial relationship for simulated individuals.
#'    \item \code{$Y}, the value in the cell contents from the input matrix.
#' }
#'
#' @examples
#' library(genomalicious)
#' data(data_Genos)
#'
#' # Subset Pop1 genotypes
#' genosPop1 <- data_Genos[POP=='Pop1', c('SAMPLE', 'LOCUS', 'GT')]
#'
#' # Get the allele frequencies for Pop1
#' freqsPop1 <- genosPop1[, .(FREQ=sum(GT)/(length(GT)*2)), by=LOCUS]
#'
#' # Simulate 100 families
#' simFamily <- family_sim_data(
#'    freqData=freqsPop1,
#'    locusCol='LOCUS',
#'    freqCol='FREQ',
#'    numSims=100
#' )
#'
#' ### THE SIMULATED GENETIC RELATIONSHIPS MATRIX
#' library(AGHmatrix)
#'
#' # Convert simulated families into a genotype matrix
#' simGenosMat <- DT2Mat_genos(simFamily)
#'
#' # Calculate the GRM
#' simGRM <- Gmatrix(simGenosMat, method='Yang', ploidy=2)
#'
#' ### THE FAMILAL ANNOTATIONS
#' # From a pairwise matrix (the GRM)
#' family_sim_annotate(simFam = simGRM, type = 'matrix')
#'
#' # From a vector of unique individual IDs
#' family_sim_annotate(simFam = rownames(simGRM), type = 'id_vec')
#'
#' @export
family_sim_annotate <- function(simFam, type){
if(type=='matrix'){
if(!'matrix' %in% class(simFam)){
stop('Argument `simFam` must be of class "matrix" if argument `type` == "matrix". See ?family_sim_annotate.')
}
}
if(type=='id_vec'){
if(!'character' %in% class(simFam)){
stop('Argument `simFam` must be of class "character" if argument `type` == "id_vec". See ?family_sim_annotate.')
}
}
require(data.table); require(tidyverse)
# Sort the individual sample IDs based on input type
if(type=='matrix'){
annotDT <- simFam %>%
as.matrix() %>%
pairwiseMat2DT(., X1='SAMPLE1', X2='SAMPLE2', Y='Y') %>%
.[SAMPLE1!=SAMPLE2]
} else if(type=='id_vec'){
annotDT <- combn(sort(unique(simFam)), 2) %>%
t() %>%
as.data.table %>%
setnames(., new=c('SAMPLE1', 'SAMPLE2'))
}
# Simulation ID
annotDT[, SIM1:=sub('_.*', '', SAMPLE1)]
annotDT[, SIM2:=sub('_.*', '', SAMPLE2)]
# All individuals from different simulations are unrelated
annotDT[SIM1!=SIM2, FAMILY:='Unrelated']
# The simulated unrelated pair within simulations
annotDT[
SIM1 == SIM2 &
grepl('_unrel_',SAMPLE1)==TRUE &
grepl('_unrel_',SAMPLE2)==TRUE,
FAMILY:='Unrelated'
]
# The simulated sibling pair within simulations
annotDT[
SIM1 == SIM2 &
grepl('_sib_',SAMPLE1)==TRUE &
grepl('_sib_',SAMPLE2)==TRUE,
FAMILY:='Siblings'
]
# The simulated half-sibling pair within simulations
annotDT[
SIM1 == SIM2 &
grepl('_halfsib_',SAMPLE1)==TRUE &
grepl('_halfsib_',SAMPLE2)==TRUE,
FAMILY:='Half-siblings'
]
# The simulated cousins pair within simulations
annotDT[
SIM1 == SIM2 &
grepl('_cous_',SAMPLE1)==TRUE &
grepl('_cous_',SAMPLE2)==TRUE,
FAMILY:='Cousins'
]
# The simulated half-cousins pair within simulations
annotDT[
SIM1 == SIM2 &
grepl('_halfcous_',SAMPLE1)==TRUE &
grepl('_halfcous_',SAMPLE2)==TRUE,
FAMILY:='Half-cousins'
]
# All other pairs within simulations are unrelated
annotDT[SIM1 == SIM2 & is.na(FAMILY), FAMILY:='Unrelated']
# Add in a simulation column
annotDT <- annotDT[, SIM:=paste0(SIM1, '|', SIM2)] %>%
.[, !c('SIM1','SIM2')]
# Output
if(type=='matrix'){
return(annotDT[, c('SIM','SAMPLE1','SAMPLE2','FAMILY','Y')])
} else if(type=='id_vec'){
return(annotDT[, c('SIM','SAMPLE1','SAMPLE2','FAMILY')])
}
}
family_sim_annotate(simFam = rownames(simGRM), type = 'id_vec')
simFam
family_sim_annotate(simFam)
family_sim_annotate(simFam, type='id_vec')
family_sim_annotate(simFam, type='id_vec') %>%
.[FAMILY=='Unrelated', A:=0] %>%
.[FAMILY=='Half-cousins', A:=0.0625] %>%
.[FAMILY=='Cousins', A:=0.125] %>%
.[FAMILY=='Half-siblings', A:=0.25] %>%
.[FAMILY=='Siblings', A:=0.5] %>%
pairwiseMat2DT(., flip=TRUE, X1='SAMPLE1', X2='SAMPLE2', Y='A', diagAdd=TRUE, diagVal=1)
Amat <- family_sim_annotate(simFam, type='id_vec') %>%
.[FAMILY=='Unrelated', A:=0] %>%
.[FAMILY=='Half-cousins', A:=0.0625] %>%
.[FAMILY=='Cousins', A:=0.125] %>%
.[FAMILY=='Half-siblings', A:=0.25] %>%
.[FAMILY=='Siblings', A:=0.5] %>%
pairwiseMat2DT(., flip=TRUE, X1='SAMPLE1', X2='SAMPLE2', Y='A', diagAdd=TRUE, diagVal=1)
Amat[1:10, 1:10]
#' The additive genetic relatedness matrix for simulated individuals
#'
#' Takes individuals generated from \code{family_sim_data} and returns an
#' additive genetic relatedness matrix
#'
#' @param simFam Character: A vector of simulated indivdiual sample IDs
#'
#' @returns Returns a symmetrical matrix of additive genetic relationships
#' between all pairs of individuals.
#'
#' @examples
#' library(genomalicious)
#' data(data_Genos)
#'
#' # Subset Pop1 genotypes
#' genosPop1 <- data_Genos[POP=='Pop1', c('SAMPLE', 'LOCUS', 'GT')]
#'
#' # Get the allele frequencies for Pop1
#' freqsPop1 <- genosPop1[, .(FREQ=sum(GT)/(length(GT)*2)), by=LOCUS]
#'
#' # Simulate 100 families
#' simFamily <- family_sim_data(
#'    freqData=freqsPop1,
#'    locusCol='LOCUS',
#'    freqCol='FREQ',
#'    numSims=100
#' )
#'
#' ### THE SIMULATED ADDITIVE GENETIC RELATEDNESS MATRIX
#' simARM <- family_sim_Amatrix(unique(simFamily$SAMPLE))
#'
#' @export
family_sim_Amatrix <- function(simFam, type){
require(data.table); require(tidyverse)
Amat <- family_sim_annotate(simFam, type='id_vec') %>%
.[FAMILY=='Unrelated', A:=0] %>%
.[FAMILY=='Half-cousins', A:=0.0625] %>%
.[FAMILY=='Cousins', A:=0.125] %>%
.[FAMILY=='Half-siblings', A:=0.25] %>%
.[FAMILY=='Siblings', A:=0.5] %>%
pairwiseMat2DT(., flip=TRUE, X1='SAMPLE1', X2='SAMPLE2', Y='A', diagAdd=TRUE, diagVal=1)
return(Amat)
}
simARM <- family_sim_Amatrix(unique(simFamily$SAMPLE))
simARM
simARM[1:8, 1:8]
# Developer libraries
libs <- c('devtools', 'roxygen2', 'testthat', 'knitr', 'data.table', 'tidyverse')
for(L in libs){require(L, character.only=TRUE)}
# Make all documents
roxygenise(clean=TRUE)
library(genomalicious)
